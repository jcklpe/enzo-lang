//= SIMPLE IF TEST
$status-if: "ready";

If $status-if, (
  "Ready!"; // should print "Ready!"
);

//= IF CONDITION NOT MET and not
$status-if-empty: "";

If $status-if-empty, (
  "Won't print"; // shouldn't print
);

If not $status-if-empty, (
  "this should print"; // should print
);

//= ELSE TEST
$status-else: "";

If $status-else, (
  "Won't print";),
Else, (
  "Fallback triggered"; // should print
);

//= NOT CONDITION FALSE
$status-not2: "value";

If not $status-not2, (
  "Won't print";
);

If $status-not2, (
  "this should print";
);

//= IS VALUE MATCH TRUE and False
$color-match: "blue";

If $color-match is "blue", (
  "Matched blue"; // should print
);

If $color-match is "red", (
  "Won't print";
);

//= IS TYPE MATCH TRUE
$val-num: 42;

If $val-num is Number, (
  "It's a number"; // should print
);

//= IS TYPE MATCH FALSE
If $color-match is Number, (
  "Won't print";
);

//= IS EMPTY MATCH
$empty-val: ;

If $empty-val is Empty, (
  "Empty detected"; // should print
);

//= LESS THAN TRUE and FALSE
$num-less: 5;

If $num-less is less than 10, (
  "Less than 10"; // should print
);

If $num-less is less than 3, (
  "Won't print";
);

//= GREATER THAN TRUE and FALSE
$num-greater: 20;

If $num-greater is greater than 10, (
  "Greater than 10"; // should print
);

If $num-greater is greater than 50, (
  "Won't print";
);

//= AT MOST (<=) TRUE and FALSE
$num-at-most: 10;

If $num-at-most is at most 10, (
  "At most 10"; // should print
);

If $num-at-most is at most 9, (
  "Won't print";
);

//= AT LEAST (>=) TRUE and FALSE
$num-at-least: 10;

If $num-at-least is at least 10, (
  "At least 10"; // should print
);

If $num-at-least is at least 20, (
  "Won't print";
);

//= CONTAINS TRUE and FALSE
$list-contain: [1, 2, 3];

If $list-contain contains 2, (
  "Contains 2"; // should print
);

If $list-contain contains 5, (
  "Won't print";
);

//= AND
$status-and: "active";
$count-and: 5;

If $status-and is "active" and $count-and is 5, (
  "Both conditions true"; // should print
);

If $status-and is "inactive" and $count-and is 5, (
  "Won't print";
);

//= OR
If $status-and is "inactive" or $count-and is 5, (
  "At least one true"; // should print
);

If $status-and is "inactive" or $count-and is 10, (
  "Won't print";
);

//= ELSE IF FIRST MATCH
$status-elseif: "first";

If $status-elseif is "first", (
  "First match"; ), // should print
Else if $status-elseif is "second", (
  "Second match";),
Else, (
  "Fallback";
);

//= ELSE IF SECOND MATCH
$status-elseif<: "second";

If $status-elseif is "first", (
  "Won't print";),
Else if $status-elseif is "second", (
  "Second match";),  // should print
Else, (
  "Fallback";
);

//= ELSE IF FALLBACK MATCH
$status-elseif<: "third";

If $status-elseif is "first", (
  "Won't print";),
Else if $status-elseif is "second", (
  "Won't print";),
Else, (
  "Fallback matched"; // should print
);

//= MULTI-BRANCH SWITCH
$switch-val: "B";

If $switch-val either is "A", (
  "A";),
or is "B", (
  "B matched";),  // should print
or is "C", (
  "C";
);

//= MULTI-BRANCH WITH DEFAULT (Otherwise FALLBACK)
$fruit<: "orange";

If $fruit either is "banana", (
  "Banana";),
or is "apple", (
  "Apple";),
Otherwise, (
  "Fallback fruit"; // should print
);

//= MULTI-BRANCH TYPE GUARD MATCHING
$value: 15;

If $value either is Number and is greater than 10, (
  "Big number";),  // should print
or is Number and is at most 10, (
  "Small number";),
Otherwise, (
  "Not a number";
);

//= MULTI-BRANCH TYPE MATCH WITH VARIANT
Magic-Type2 variants: Fire,
                    or Ice,
                    or Wind,
                    or Earth,
                    or Neutral;

$type-val: Magic-Type2.Ice;

If $type-val either is Magic-Type2.Fire, (
  "Fire type";),
or is Magic-Type2.Ice, (
  "Ice type matched";),  // should print
or is Magic-Type2.Wind, (
  "Wind type";),
Otherwise, (
  "Unknown type";
);

//= MULTI-BRANCH CONTAINS MATCH
$bag: ["coin", "key", "map"];

If $bag either contains "sword", (
  "Sword found";),
or contains "key", (
  "Key found";),  // should print
Otherwise, (
  "No useful items";
);

//= MULTI-BRANCH COMPOUND LOGIC
$compound: 3;

If $compound either is Number and is greater than 10, (
  "Big number";),
or is Number and is at most 5, (
  "Small number matched";),  // should print
or is Number, (
  "Number matched";),
Otherwise, (
  "Fallback";
);

//= MULTI-BRANCH LIST EXACT MATCH
$list-exact: [1,2,3];

If $list-exact either is [3,2,1], (
  "Reverse matched";),
or is [1,2,3], (
  "Exact list matched";),  // should print
Otherwise, (
  "No exact list match";
);

//= MULTI-BRANCH WITH VARIANT GROUP
Monster-Branch variants: Goblin, or Orc, or Troll;

$monster-type1: Monster-Branch.Goblin;

If $monster-type1 either is Monster-Branch.Orc, (
    "Orc matched";),
  or is Monster-Branch.Goblin, (
    "Goblin matched";),  // should print
  or is Monster-Branch.Troll, (
    "Troll matched";),
  Otherwise, (
    "No monster match";
);

//= INLINE IF TRUE and FALSE
$inline-if: "ready";
If $inline-if, ( "Go!"); // prints "Go!"
$inline-if<: "";
If $inline-if, ("Go!"), Else, ("Wait!"); // prints "Wait!"

//= BOOLEAN EDGE CASE FALSE CONDITIONS
If 0, ("Won't print1");
If "", ("Won't print2");
If [], ("Won't print3");
If [0,0,0], ("Won't print4");
If False, ("Won't print5");
If Status.False, ("Won't print6");
If not 0, ("will print");
If not "", ("will print");
If not [], ("will print");
If not [0,0,0], ("will print");
If not False, ("will print");
If not Status.False, ("will print");

//= BOOLEAN EDGE CASE TRUE CONDITIONS
If Monster-Branch, ("True variant group"); // prints
If Monster-Branch.Goblin, ("True variant value"); // prints
If "hi", ("True text atom"); // prints

//= Function Atom as condition
If ( ), ("Won't print1"); // empty function atom shouldn't trigger

If (4 + 5), ("Will print"); // function with value should trigger

If (5 - 5), ("Won't print2"); // function returns 0 which is a false condition

If not (5 - 5), ("Will print"); // function returns 0 which is a false condition

//= IF WITH FUNCTION RETURNING EMPTY (FALSY)
empty-fn-test: ();

If empty-fn-test(), (
  "Won't print";),
Else, (
  "Empty function result"; // should print
);

//= IF WITH FUNCTION RETURNING NON-EMPTY (TRUTHY)
non-empty-fn-test: ("result";);

If non-empty-fn-test(), (
  "Non-empty function result"; // should print
);

//= IF WITH VARIABLE SET TO EMPTY LIST THEN MUTATED TO TRUTHY LIST
$list-mutate: [];

If $list-mutate, (
  "Won't print initially";
);

$list-mutate <: [1];

If $list-mutate, (
  "List became truthy"; // should print
);

//= IF WITH VARIABLE SET TO TEXT "0" (TRUTHY)
$text-zero: "0";

If $text-zero, (
  "Text '0' is truthy"; // should print
);

//= IF WITH VARIABLE SET TO NUMBER 0.0 (FALSY)
$num-zero: 0.0;

If $num-zero, (
  "Won't print"),
Else, (
  "0.0 is falsy"; // should print
);

//= IF WITH EMPTY BLUEPRINT INSTANCE (TRUTHY)
EmptyBP: <[]>;
$empty-bp: EmptyBP[];
If $empty-bp, (
  "Empty blueprint is falsy"),  // shouldn't print
Else, (
  "Empty blueprint is falsy!";  //should print
);

//= IF WITH VARIABLE SET TO STATUS.FALSE THEN MUTATED TO CUSTOM STATUS (TRUTHY)
$status-custom: Status.False;
If $status-custom, (
  "Won't print initially";
);

Status variants include Loading, or Dead;

$status-custom <: Status.Loading;

If $status-custom, (
  "Custom status is truthy"; // should print
);

//= MULTI-BRANCH MATCH WITH SECOND TRUTHY MATCH
$multi-branch: "second";

If $multi-branch either is "first", (
  "First matched"),  // shouldn't print
or is "second", (
  "Second matched";
);

//= MULTI-BRANCH MATCH WITH MULTIPLE TRUTHY CONDITIONS, ONLY FIRST EXECUTES
$multi-branch-num: 10;

If $multi-branch-num either is at least 5, (
  "At least 5 matched"),  // should print
or is Number, (
  "Generic number matched (shouldn't print)";
);

//= MULTI-BRANCH MATCH WITH MULTIPLE TRUTHY CONDITIONS, ALL EXECUTE
$multi-branch-num1: 10;

If $multi-branch-num1 is at least 5, (
  "At least 5 matched"),  // should print
or is Number, (
  "generic number should print"; // should print
);

//= ERROR CASE: USING UNDEFINED VARIABLE IN IF
If $undefined-var, ( // error: undefined variable
  "Won't print";
);

//= ERROR CASE: INVALID COMPARISON TYPE
If $list-contain is less than 10, ( // error: can't compare list with number comparison word
  "Won't print";
);

//= ERROR CASE: INVALID USE OF "CONTAINS" ON NON-LIST
$non-list-val: 10;

If $non-list-val contains 1, ( // error: contains used on non-list
  "Won't print";
);

//= ERROR CASE: INVALID MULTI-BRANCH "or" WITHOUT PRECEDING IF
or "value", ( // error: `or` without preceding `If`
  "Won't print";
);

//= ERROR CASE: ELSE IF WITHOUT INITIAL IF
Else if $color is "blue", ( // error: `Else if` without preceding `If`
  "Won't print";
);

//= ERROR CASE: ELSE WITHOUT INITIAL IF
Else, ( // error: `Else` without preceding `If`
  "Won't print";
);

//= BOOLEAN TEST: LIST WITH ALL FALSY ELEMENTS
$list-all-falsy: [0, "", [], False];

If $list-all-falsy, (
  "won't print"; // shouldn't print
);

If not $list-all-falsy, (
  "All falsy elements in a list are falsy"; // should print
);

//= BOOLEAN TEST: TEXT WITH WHITESPACE ONLY (TRUTHY)
$text-whitespace: "   ";

If $text-whitespace, (
  "Whitespace text is truthy"; // should print
);

//= BOOLEAN TEST: VARIABLE WITH EMPTY BLUEPRINT VARIANT (TRUTHY)
EmptyVariantBP variants: Empty, or Filled;

$empty-variant: EmptyVariantBP.Empty;

If $empty-variant, (
  "Empty variant is truthy"; // should print
);

//= BOOLEAN TEST: EMPTY PARAMETERIZED FUNCTION (FALSY)
$empty-param-fn: (param $x: ;);

If $empty-param-fn, (
  "Won't print"),
Else, (
  "Empty parameterized function is falsy"; // should print
);

//= INLINE IF WITH VARIABLE SET TO NUMBER 1 (TRUTHY)
$inline-num: 1;

If $inline-num, ("Number 1 is truthy"), Else, ("Won't print"); // prints truthy

//= INLINE IF WITH EMPTY LIST (FALSY)
$inline-list: [];

If $inline-list, ("Won't print"), Else, ("Empty list falsy"); // prints falsy

//= DESTRUCTURE IN IF CONDITION (Truthy)
$person21: [$name21: "Eve", $age21: 28];
$name21, $age21: $person21[];

If $age21 is greater than 21, (
  "<$name21> is over 21"; // should print "Eve is over 21"
);

//= DESTRUCTURING BY REFERENCE AND MUTATION IN CONTROL FLOW
$player21: [$hp21: 50, $status21: "alive"];

@player21[] :> $hp21, $status21;

If $hp21 is less than 100, (
  100 :> $hp21; // mutate referenced destructured variable
);

$player21.hp; // should now be 100

//= MULTI-STAGE PIPELINE WITH CONDITIONAL STEP ERROR
$list-pipe: [1,2,3,4];

$list-pipe
then ($this contains 4) :> $contains-four;  // error: comparison word in pipeline

//= Has function and pipeline
has1: (
  param $list: ;
  param $value: ;

  If $list contains $value, (return(True)), Else,  (return(False));
);

$list-pipe22: [1,2,3,4];

$list-pipe22 then has1($this, 4) :> $contains-four22;

If $contains-four22, (
  "List contains four"; // should print
);

//= IF CONDITION WITH LIST INDEX ACCESS
$list-index23: ["zero", "one", "two"];

If $list-index23.2 is "one", (
  "Second index matched 'one'"; // should print
);

If $list-index23.3 is "one", (
  "Won't print"),
Else, (
  "Third index is not 'one'"; // should print
);

//= LIST MAPPING WITH CONTROL FLOW CONDITION
$user-map: [$username: "alice", $active: "yes"];

If $user-map.active is "yes", (
  "<$user-map.username> is active"; // should print "alice is active"
);

//= LIST MAPPING AND PIPELINE INTO CONTROL FLOW
$user-map
then ($this.active) :> $is-active;

If $is-active is "yes", (
  "User active status: yes"; // should print
);

//= BLUEPRINT DEFAULTS IN CONTROL FLOW
Character: <[$hp: 100, $mana: 50]>;

$hero: Character[];

If $hero.hp is at least 100, (
  "Hero at full health"; // should print
);

//= ERROR: IF CONDITION ACCESSING INVALID LIST INDEX
$bad-list50: [1,2,3];

If $bad-list50.4, ( // error: list index out of range
  "Won't print";
);

//= ERROR: IF CONDITION ON UNDEFINED PROPERTY IN LIST
$user-bad: [$name: "Bob"];

If $user-bad.age, ( // error: list property `$age` not found
  "Won't print";
);

//= More destructuring stuff and conditionals stuff
$nums29: [5,6,7];

$x29, $y29, $z29: $nums29[];

If $x29 is 5 and $y29 is 6 and $z29 is 7, ("Pass: positional destructure");

//= multiple statements in an inline if
If True, ("passing one statement from inline If"; "passing a second one"); // prints both lines

If True, ($inline-value: 5; $inline-value);  // prints 5

If False, ("this shouldn't print"), Else, ($inline-value2: 6; $inline-value2;);  // prints 6

//= IF WITH NESTED CONDITIONALS
$status-nested: "outer";

If $status-nested is "outer", (
  If $status-nested, (
    "Nested condition true"; // should print
  );
);

//= PIPELINE WITH INLINE FUNCTION RETURNING EMPTY (FALSY)
empty-fn-pipeline: ();

empty-fn-pipeline() then ($this) :> $pipeline-empty;

If not $pipeline-empty, (
  "Pipeline resulted in empty"; // should print
);

//= BOOLEAN TEST: NESTED LIST WITH TRUTHY AND FALSY ELEMENTS
$nested-list66: [0, "", [0, "valid"]];

If $nested-list66, (
  "Nested list considered truthy"; // should print
);

//= ERROR: USING "is" WITH A VARIANT THAT DOES NOT EXIST
If $status-bp is StatusVariantBP.Unknown, (// error: undefined variable
  "Won't print";
);

//= Conditional pipelining
$goblinoid: [
  $health: 30,
  $status: "alive"
];

take-damage1: (
  param $target: ;
  param $damage: 0;
  $target.health - $damage :> $target.health;
  return($target);
);

set-status: (
  param $target: ;
  param $status: "";
  $status :> $target.status;
  return($target)
);

$goblinoid
  then take-damage1($this, 30)
    then If $this.health is less than 1, (
        set-status($this, "dead")
    )
  :> $goblinoid;

$goblinoid.health;  // should print 0
$goblinoid.status;  // should print "dead"

//= IF CONDITION WITH NESTED LIST INDEX ACCESS
$nested-list: [["zero", "one"], ["two", "three"]];

If $nested-list.2.1 is "two", (
  "Nested index matched 'two'"; // should print
);