//= ANON REF: ASSIGNMENT TO A VARIABLE
// The simplest use case: storing an anonymous function reference in a variable.
$anon_ref_add_one: @(param $x: ; return($x + 1));

// Prove it's a function by calling it.
$anon_ref_add_one(5); // prints 6

// Prove its type with a conditional check.
If $anon_ref_add_one is Function, (
    "Variable holds a function reference"; // Should print
);

//= ANON REF: STORING IN A LIST
// A common use case for callbacks or strategies.
$anon_ref_ops: [
    @(param $n: ; $n * 2), // Doubler
    @(param $n: ; $n * $n), // Squarer
    "not-a-function"
];

// Invoke the first function from the list.
$anon_ref_ops.1(10); // prints 20

// Invoke the second function from the list.
$anon_ref_ops.2(10); // prints 100

//= ANON REF: PASSING DIRECTLY AS A FUNCTION ARGUMENT
// Defines a higher-order function that accepts a function and a value.
anon_ref_apply: (
    param $func: ;
    param $value: ;
    return( $func($value) );
);

// Pass an anonymous function reference directly as an argument.
anon_ref_apply( @(param $text: ; "Hello, <$text>!"), "Enzo" ); // prints "Hello, Enzo!"

//= ANON REF: IN A DATA-FLOW PIPELINE (`then`)
// The anonymous function is used as a step in the pipeline.
100 then @(param $this: ; $this / 2) then @(param $this: ; "Final value: <$this>");
// prints "Final value: 50"

//= ANON REF: IN A LIST PROPERTY (METHOD)
$anon_ref_calculator: [
    $base: 10,
    $op: @(param $x:; $x + $self.base)
];

$anon_ref_calculator.op(5); // Uses $self to access list properties. Prints 15

//= ANON REF: NESTED ANONYMOUS REFERENCE
// An anonymous function that *returns* another anonymous function reference.
$anon_ref_creator: @(
    param $prefix: ;
    return( @(param $text:; "<$prefix> <$text>") );
);

// Call the outer function to get the inner function.
$anon_ref_logger: $anon_ref_creator("[LOG]");
// Call the inner function.
$anon_ref_logger("System Ready"); // prints "[LOG] System Ready"

//= ERROR CASE: FORGETTING THE `@` SIGIL
// Without `@`, the function atom is immediately evaluated (demand-driven).
// It returns a Function *object*, which is not a Number, causing a type error inside the function.
anon_ref_apply( (param $x:; $x * 2), 5 ); // error: Mismatched types or invalid operation inside anon_ref_apply.

//= ERROR CASE: SYNTAX ERROR INSIDE THE FUNCTION BODY
$anon_ref_bad_syntax: @(param $x: $x + ); // error: parse error in function atom body

//= ERROR CASE: `@` INSIDE THE PARENTHESES
$anon_ref_bad_placement: (@(1+1)); // error: The `@` sigil must precede the `(` for an anonymous function reference.