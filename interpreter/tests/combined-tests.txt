//= INVOKING AN UNDEFINED VARIABLE
$undefinedVar;// error: undefined variable

//= EMPTY BIND ────────────────────────────────────────────────────────────
$x: ;

//= REDECLARING A VARIABLE (USING “:”) ERRORS ────────────────────────────
$x: 10;             // error $x has already been declared

//= REBINDING WITH “<:” AND INVOKING ───────────────────────────────────────
$x <: 100;
$x;                 // prints 100
$x <: "hello";      // error: cannot bind Text to Number

//= FULL BIND UPFRONT LOCKING TYPE ──────────────────────────────────────────
$z: 7;       // binds 7
$z;         // prints 7
$z <: 8;            // rebind OK, z now 8
$z;             // prints 8
$z <: "oops";       // error: cannot bind Text to Number
$z : "oops";       // error: $z already defined

//= MIXED‐CASE VARIABLE NAMES ───────────────────────────────────────────
$Var123: 10;
$Var123;                  // prints “10”
$var-xyz: 20;
$var-xyz;                 // prints “20”
$Var123 + $var-xyz;       // prints “30”
$var_xyz: 30;
$var_xyz;                 // prints “30”

//= REBINDING WITH “:>” IMPLICITLY BINDS IF NEEDED ────────────────────────
55 :> $newImplicit;
$newImplicit;               // prints “55”
$newImplicit <: "oops";     // error: cannot bind Text to Number
$dougie <: "cool dude";     // should not error.
$dougie;                    // prints "cool dude".

//= MULTIPLE ASSIGNMENTS ON ONE LINE ────────────────────────────────────
$u: 1; $v: 2; $u + $v;    // prints “3”
$apples:1;$bananas:2; $apples+$bananas;       // prints 3
$apricot :  1 ; $boranges: 2;        // spacing should not break anything
$boranges;

//= Var naming
$123abc: 5;
$123abc; // prints 5
$_: 9;
$_; // prints 9
$-foo: 3;
$-foo;        // prints 3

//= LIST STUFF & INDEX ERRORS ─────────────────────────────────────────────
$emptyListTest: []; // binds []
$emptyListTest;    // prints “[]”
$emptyListTest.1;  // error: List index out of range

//= BIND EMPTY AND THEN FILL WITH LIST ────────────────────────────────────
$empty-list: ;
$empty-list: 50;    //error: $empty-list already defined
$empty-list<: ["now not empty"];  //bind contents to List
$empty-list;       // prints “["now not empty"]”

//= DECLARE LIST AND ACCESS ITEMS ────────────────────────────────────────
$colors: ["red", "green", "blue", "yellow"]; // binds List
$colors.3;         // prints “blue”
$i: 2;             // binds 2
$colors.$i;        // prints “green”

//= NESTED LISTS WITH INDEXING ────────────────────────────────────────────
$nestedList: [[1, 2], [3, 4]];
$nestedList.2.1;   // prints “3”

//= MIXED LIST‐INSIDE‐LIST ● INDEX VS ATTR ──────────────────────────────
$mix: [$lst: ["a", "b", "c"]];  //binds List
$mix.lst.2;                // prints “b”

//= LIST OF LISTS + INDEX OF LIST ────────────────────────────────────
$lol-index: [[$x: 5], [$x: 7]];  // binds List
$lol-index;                 // prints “[[$x: 5], [$x: 7]]”
$lol-index.2.x;             // prints “7”

//= Out-of-bounds and weird List indices
$list: [1,2,3];     // binds List
$list;
$list.0;            // error: List index out of range
$list.4;            // error: List index out of range
$list.-1;           // error: List index out of range
$list."foo";        // error: can't use text as index or keyname
$list.1.1;          // error: List index out of range

//= List mutation
$mutable: [1,2];
$mutable;
$mutable.1 <: 5;        // updates first element to 5
$mutable;               // prints [5, 2]
$mutable.3 <: 9;        // error: List index out of range

//= Trailing commas
// These are fine
$goodList-index: [1, 2, 3,]; // binds List
$goodList-index;              // prints  [1, 2, 3]
// these should error
$badList1-index: [1,,2];                        // error: remove one comma
$badList2-index: [,1,2];                        // error: leading comma
$badList3-index: [,];                           // error: just comma

//= Various type errors
$notalist: "oops";
$notalist;
$notalist.1;                              // index applies to Lists

//= BINDING MATH OPERATIONS ────────────────────────────────────────────────
$math1: 100;    // binds 100
$math1;            // prints 100
$math2: (3 + 2);          // binds a function atom
$math2; // prints 5
($math1 + $math2);            // prints 105

//= ARITHMETIC PRECEDENCE CHECK ─────────────────────────────────────────────
$precedence-check: (2 + 3 * 4);      // binds a function atom
$precedence-check;                 // prints 14

$precedence-check2: ((2 + 3) * 4);    // binds a function atom
$precedence-check2;                 // prints 20

//= PARENTHESIZED EXPRESSIONS AS STAND‐ALONE ─────────────────────────────
(10 + 5);                 // prints “15”

//= LARGE NUMBERS + NEGATIVE NUMBERS ────────────────────────────────────
$big: 1234567890;         // binds “1234567890”
$big;                     // prints “1234567890”
$neg: -5;                 // binds “-5”
$neg;                     // prints “-5”
($neg * 2);                 // prints “-10”
$negzero: -0;             // binds 0 (should not crash)
$negzero;                 // prints 0 (should not crash)
$weird: --5;              // error: double minus not allowed

//= Modulo Basics
(5%2); // prints 1
5%3; // prints 2
5%5; // prints 0
50 % 5;  // prints 0
8 % 2; // prints 0

//= MODULO WITH NEGATIVES
-5 % 3;     // 1
5 % -3;     // 2
-5 % -3;         // should return 1

//= MODULO WITH ZERO DIVIDEND
0 % 3;           // should return 0

//= MODULO BY 1
7 % 1;           // should return 0
-7 % 1;          // should return 0

//= MODULO BY -1
7 % -1;          // should return 0
-7 % -1;         // should return 0

//= MODULO WITH LARGE NEGATIVE DIVIDEND
-13 % 4;         // should return 3

//= MODULO WITH DIVISOR ZERO (ERROR)
5 % 0;           // should error: division by zero
-5 % 0;          // should error: division by zero

//= LIST MAPPING STUFF ───────────────────────────────────────────────────────────
$list-map: [$name: "Alice", $age: 30];
$list-map;             // binds “[$name: "Alice", $age: 30]”
$list-map.name;        // prints “Alice”
$list-map.age;         // prints “30”

//= REBINDING LIST PROPERTIES ────────────────────────────────────────────
$list-map.name <: "Bob";
$list-map.name;        // prints “Bob”
$list-map;             // prints “[$name: "Bob", $age: 30]”

//= ANOTHER LIST + PROPERTY REBIND ───────────────────────────────────────
$list-map2: [$foo: 42, $bar: "hello"];
$list-map2;
$list-map2.bar;        // prints “hello”
$list-map2.foo <: 100;
$list-map2.foo;
$list-map2;            // prints “[$foo: 100, $bar: "hello"]”

//= EMPTY LIST LITERAL + BAD PROP ACCESS ERROR ──────────────────────────
$emptyListMap: [];
$emptyListMap;            // prints “[]”
$emptyListMap.someKey;    // error: Keyname '$someKey' does not exist on this List

//= NESTED LIST + MIXED INDEX/PROPERTY ───────────────────────────────────────
$nestedListMap: [
    $inner: [
        $val: 42,
        $arr: [10, 20]
]
];
$nestedListMap;
$nestedListMap.inner.val;     // prints “42”
$nestedListMap.inner.arr.2;   // prints “20”

//= REBINDING NESTED LISTS ───────────────────────────────────────────────
$nestedListMap.inner.val <: 100;
$nestedListMap.inner.val;     // prints “100”

//= COMPLEX LIST INDEX/PROPERTY ACCESS ─────────────────────────
$complex: [
    $list-map: [$a: [100, 200], $b: "x"],
    $list-index: [[$foo: 1], [$foo: 2]]
];
$complex;           // prints [$list-map: [$a: [100, 200], $b: "x"], $list-index: [[$foo: 1], [$foo: 2]]]
$complex.list-map.a.1;    // prints “100”
$complex.list-index.2.foo;  // prints “2”

//= LIST OF LISTS + INDEX OF LIST ─────────────────────────────────────
$lol: [$first: [1, 2], $second: [3, 4]];
$lol;
$lol.first.2;         // prints “2”
$lol.second;          // prints “[ 3, 4]”

//= MORE LIST WEIRDNESS
$deep-list: [$x: [$y: [$z: 7]]];
$deep-list;            // prints [$x: [$y: [$z: 7]]]
$deep-list.x.y.z; // prints 7

//= List property errors
$list9: [$foo: 1];
$list9;                // prints [$foo: 1]
$list9.bar;         // error: List property '$bar' not found
$list9.1;           // prints 1
$list9.foo.bar;     // error: List property '$bar' not found

$prim: 999;
$prim;                      // prints 999;
$prim.someKey <: 5;       // error: List property '$someKey' not found

$myList: [$a: 1];
$myList;                    // prints [$a: 1]
$myList.1;                 // prints 1

$table-error: [$x: 1];
$table-error;                   // prints [$x: 1]
$table-error.x <: 99;           // rebinds 99 to $table-error.x
$table-error.x;                 // prints 99
$table-error;                   // prints [$x: 99]
$table-error.y <: 42;           // error: List property '$y' not found

//= Valid trailing commas (should succeed)
$goodList: [$foo: 1, $bar: 2,];
$goodList;

//= invalid trailing commas (should error)
$badList1: [$foo: 1,, $bar: 2];
$badList2: [ ,$foo: 1, $bar: 2];
$badList3: [ ,];

//= TEXT + INTERPOLATION ───────────────────────────────────────────────────
$text-example: ;
$text-example <: "rebinding this text and ";
$text-example;
$text-example2: "this is text example 2";
$text-example2;

"just a plain text";   // prints “just a plain text”

"<$text-example; $text-example2;>";   // prints “rebinding this text and this is text example 2”
$math1-interp: 100;
$math1-interp;
$math2-interp: 5;
$math2-interp;
"<$math1-interp;> plus <$math2-interp;> is: <($math1-interp + $math2-interp);>";           // prints “100 plus 5 is: 105”

//= NOW THAT $colors & $i ARE DEFINED, INTERPOLATE A STRING THAT USES THEM ─
$index-interp: 2;
$index-interp;
$colors-interp: ["red", "purple", "green", "silver"];
$colors-interp;
$text-about-colors-list: "color <$index-interp;> is <$colors-interp.$index-interp;>";
$text-about-colors-list;   // prints “color 2 is purple

//= COMPLEX MATH INTERPOLATION ● MULTIPLE EXPRESSIONS ───────────────────
$x <: 7;
$x;
$y <: 3;
$y;
"Sum=<($x + $y);> Prod=<($x * $y);>";   // prints “Sum=10 Prod=21”

//= COMPOUND INTERPOLATION WITH LIST ACCESS ────────────────────────
$myList-text: [$greeting: "hi", $nums: [2, 4]];
$myList-text;
"<$myList-text.greeting;>! The nums are:<$myList-text.nums.1;>, and <$myList-text.nums.2;>";
                         // prints “hi! The nums are: 2,4”

//= Unicode and weird strings
$str: "π≈3.14";
$str;                   // prints π≈3.14
$esc: "foo\nbar";       // binds foo\nbar
$esc;
$esc2: "foo\"bar\"baz";
$esc2;                  // prints foo"bar"baz

//= Interpolation errors
"text <bad syntax>";    // error: undefined variable or parse error in interp
"hello <$foo + >";      // error: parse error in interpolation
"hello <<$foo>>";       // error: nested <...> not allowed (for now)

// ── FUNCTIONS  -------------------
//= Empty function atom
();  // prints nothing
//= Function atom with just a single value
(6);  // prints 6

//= Function atom with single variable and implicit return
($foo: 99; $foo); // prints 99

//= Nested function atoms
(($x: 2; $y: 3; $x * $y);); // prints 6
(($x: 3; $y: 3; $x * $y)); // prints 9
//= Function atom one liner with implicit return
($x: 3, $y: 2; $x + $y);   // prints 5
($x: 3; $y: 3; $x + $y);   // prints 6
// (both commas and semicolons work for breaking up variables in single line statements)

//= Function with only a return statement (multi-line)
(
    return(123);
); // prints 123

//= Multiline function atom with explicit return
(
$x: 100;
$y: 100;
return(($x + $y));

); // prints 200

//= Multiline function atom with explicit return 2
($x: 101;
$y: 100;
return(($x + $y));); // prints 201

//= Multiline nested function atoms
(
    $a: 10;
    $b: 20;
    return((
        $c: 2;
        return(($a + $b + $c));
    ));
); // prints 32

//= Single line, implicit return, named function
times2: (2 * 2); // binds (2 * 2) to the times2 keyname
"this is the normal function invocation;";
times2();       // prints 4
"this is the $times2 style function invocation;";
$times2;       // prints 4
"this is the $times2(); style function invocation";
$times2();       // prints 4

//= Nameless function: multi-line with no explicit return
($x: 1;
 $y: 2;
 $x + $y; // prints 3
);

//= Multi-line with params and default values
adder: (
param $x: 6; // these are default values
param $y: 6;
return(($y + $x));
);

adder();                       // prints 12
$adder();                      // prints 12
$adder;                      // prints 12

//= passing functions as references
$referenced-function: @adder;  // does not invoke adder function just saves it to another variable as a reference
$referenced-function();        // prints 12
adder(4, 5);                   // prints 9
adder(4, 5, 6);                // error: too many args
$adder("", 500);               // error: expected argument is a Number atom, not a Text atom
$referenced-function(300, 5);    // prints 305

//= Named function with local variable
adder-plus-1: (
    param $x: 6;
    param $y: 4;
    $z: 1;
    return($x + $y + $z);
);

adder-plus-1();    // prints 11
adder-plus-1(2, 2);   // prints 5

//= Subtraction with empty default
$subtractor: (
    param $x: ;
    param $y: ;
    return($x - $y);
);

subtractor(3, 2);   // prints 1
$subtractor(3, 4);   // prints 1
subtractor();        // error: missing necessary params

$subtractor(4);   //error: missing necessary params
//= List of functions invoked by index
$funs: [(param $x: ; $x + 1;), (param $x: ; $x * 2;)];
$funs.1(10);              // → 11
$funs.2(10);              // → 20

//= Named function, then function reference and direct invocation
double: (param $x: 2; $x * 2);
$ref: @double;       // should NOT invoke — should just bind the function object
$ref(5);             // → 10

// Direct invocation should work too:
double(3);           // → 6

// Function reference must use $, no parens:
double;              // error: expected function reference (@) or function invocation ($)
//= Higher-order function: passing function as argument and using default argument
apply: (
    param $function-arg:;
    param $value: 7;
    return($function-arg($value));
);

apply(@double, 4);   // → 8
apply(@double);      // → 14 (default $val: 7)

apply(double, 4);    // error: expected function reference (@) or function invocation ($)

//= List with function member and self mutation
$counter: [
    $count: 10,
    increment: (
        $self.count + 1 :> $self.count;
        return($self.count);
    )
];
$counter.count;      // → 10
$counter.increment();      // → 11
$counter.increment();      // → 12
$counter.count;      // → 12
@counter.increment;        // function doesn't invoke, just returns the counter.increment function as a reference.

//= List of functions: referencing as variables
$list-reference: [
    $add-one: (
        param $x: 10;
        return($x + 1);
    )
];
$referencing-function: @list-reference.add-one;      // should be a function reference, not invoked
$referencing-function();              // → 11
$referencing-function(5);             // → 6

//= Nested function: inner function shadows param
outer: (
    param $x: 10;
    inner: (
        param $y: 5;
        return(($x + $y));
    );
    return($inner(7));
);
outer();             // → 17
outer(20);           // → 27

//= Duplicate param name error in function declaration
duplicate-params: (
    param $x: 1;
    param $x: 2; // error: duplicate parameter name '$x' in function definition
    return($x);
);

//= Empty function declaration and invocation
empty-fn: ();
empty-fn();     // returns empty.

//= Function with default param referencing previous param
sum-default: (
    param $a: 5;
    param $b: $a;
    return(($a + $b));
);
sum-default();            // → 10
sum-default(2);           // → 4
sum-default(2, 10);       // → 12

//= List with a list of functions as a property
$calc: [
    $ops: [(param $x: ; $x + 1;), (param $x: ; $x * 2;)]
];
$calc.ops.2(4);           // → 8

//= List function and interpolation with self behavior
$doggie: [
    $name: "ralph",
    $age: 50,
    $speak: ("Hi, my name is <$self.name>."),
    $roll-over: (
        param $direction: "left";
        return ("I'm now spinning <$direction>.");
    )
];
$doggie.speak();              // prints "Hi, my name is ralph."
$doggie.roll-over("right");   // prints "I'm now spinning right."

//= Functions as members of lists
$weird-member: 20;
$weird-list: [1, 2, ($x: 9; $x + 1;), ($weird-member + 1)];
$weird-list.3; // prints 10
$weird-list.4; // prints 21

//= Function with numeric param name
number-name-param: (
    param $123: 4;
    return($123);
);
number-name-param();    // prints 4

//= Early exit
early-exit: (
    $a: 99;
    return($a);
    $a<: 1; // should not execute
);
early-exit(); // should return 99

//= Function param name shadows outer variable
$whatever: 42;
shadow: (
    param $whatever: 1;
    return($whatever);
);
shadow();    // prints 1 not 42

//= function atoms and pipes
// Single-line anonymous function returns 6
($x: 1, $y: 5; $x + $y); // → 6

// simple addition
10 then ($this + 1); // returns 11

// single value function atom to function atom
(6); then ($this + 6); // → 12

// function atom with local var
6 then ($y: 10; $this + $y); // → 16

// function atom with multiple local var
6 then ($y: 10; $z: 4; $this + $y + $z); // → 20
6 then ($y: 4, $z: 5; $this + $y + $z); // → 15

// $this passed to local var
10 then ($n: $this; $n * 2); // should return 20
10 then ($this :> $n; $n * 3); // should return 30

// Global variable
$global-pipe-var: 10;
$global-pipe-var;
10 then ($this * $global-pipe-var); // should return 100
$global-pipe-var<:5;
$global-pipe-var;
10 then ($this * $global-pipe-var); // should return 50
10 then ($this + $global-pipe-var) then ($this + $global-pipe-var); // should return 20

// Pipeline with value feeding into function
($z: 5; $z); then ($y: 5; $this + $y); // → 10

// pipeline for multiple function atoms
10 then ($this + 1) then ($this + 1); // returns 12

//= Multiline function atom
10 then (
    return($this);
); // returns 10

10 then ($x: 5;
$x + $this :> $sum;
return($sum);); // returns 15

10 then (
    $y: 6;
    $x: 4;
    return(($this + $x + $y));
); // returns 20

10 then (
    $y: 6;
    $x: 4;
    return(($this + $x + $y));
) then (
    $y: 6;
    $x: 4;
    return(($this + $x + $y));
); // returns 30

10 then ($y: 6; $x: 4; $this + $x + $y) then (
    $y: 16;
    $x: 4;
    return(($this + $x + $y));
); // returns 40

//= PIPELINE ERROR: SHADOWING $this IS DISALLOWED
10 then (
    $this: 7;
    return($this * 2);
); // error: cannot declare variable '$this'

//= PIPELINE NEGATIVE NUMBER HANDLING
-5 then ($this * 2); // returns -10
-5 then (3 * $this); // returns -15

//= PIPELINE WITH TEXT INTERPOLATION
"Hello" then ("<$this>, World!"); // returns "Hello, World!"

//= PIPELINE WITH INTERPOLATION AND MATH
5 then ("double of <$this> is <($this * 2)>"); // "double of 5 is 10"

//= PIPELINE WITH LIST MANIPULATION
[1,2,3] then ($this.2); // returns 2

//= PIPELINE NESTED LIST ACCESS
[[1,2],[3,4]] then ($this.2.1 * 10); // returns 30

//= PIPELINE LIST PROPERTY
[$val: 10] then ($this.val + 5); // returns 15
[$val: 5, $val2: 10] then ($this.val + $this.val2); // returns 15

//= PIPELINE ERROR NO FUNCTION ATOM
5 then 10; // error: pipeline expects function atom after `then`

//= PIPELINE ERROR EMPTY FUNCTION ATOM
5 then (); // returns empty, no action

//= Complex tests
// multiline function atom, nested function invocation in return
10 then (
 $this + 1 :> $num;
 $incremented: ($num + 1);
 return(($incremented * 2));
); // should return 24

// PIPELINE INDEXED LIST ACCESS USING INTERMEDIATE CALCULATION
[10,20,30] then ($index: 2; $this.$index + 5); // returns 25

// Recursive transformation
$recursed-list: [10,20,30];
$recursed-list then ($index: 2; $this.$index + 5 :> $recursed-list.$index);
$recursed-list.2;// returns 25

//= Multi-line and params in named functions
10 then ($this + 2); // Explicit, clear, always works
// or, for named functions:
adder-pipes: (
    param $x: ;
    param $y: ;
    return($x + $y);
);
10 then adder-pipes($this, 5); // Clear: pass piped value as first arg

//= NAMED FUNCTION: referencing $this is an error
breaking2: (
    param $x: ;
    param $y: ;
    return($x + $y + $this); // error: can't use reserved $this keyname in named function declaration
);

//= COPY BY DEFAULT: LISTS ───────────────────────────────────────────────────────────
$original: [1, 2, 3];
$original;  // print [1, 2, 3]
$copy: $original;        // creates a copy of the list
$copy.1 <: 99;
$copy;                   // prints [99, 2, 3]
$original;               // prints [1, 2, 3] original unaffected

//= COPY BY DEFAULT: NESTED LISTS ───────────────────────────────────────────────────
$nested-original: [$inner: [10, 20]];
$nested-copy: $nested-original;
$nested-copy.inner.1 <: 99;
$nested-copy;            // prints [$inner: [99, 20]]
$nested-original;        // prints [$inner: [10, 20]] original unaffected

//= VARIABLE REFERENCE WITH @ ───────────────────────────────────────────────────────
$original-list: [4, 5, 6];
$reference-list: @original-list;   // stores a reference explicitly
$reference-list.2 <: 99;
$reference-list;        // prints [4, 99, 6]
$original-list;         // prints [4, 99, 6] original affected due to reference

//= REFERENCE TO VARIABLE (COPY VS EXPLICIT REFERENCE) ──────────────────────────────
$x-ref: 100;
$y-ref: $x-ref;                 // copy by default
$y-ref <: 200;
$x-ref;                     // prints 100 (original unaffected)
$y-ref;                     // prints 200

$ref-x: @x-ref;            // explicit reference
$ref-x <: 300;
$ref-x;                 // prints 300
$x-ref;                     // prints 300 (original affected due to reference)

//= FUNCTION ARGUMENT REFERENCE VS COPY ──────────────────────────────────────────────
modify-list: (
    param $lst: ;
    $lst.1 <: 99;
    return($lst);
);

$test-list: [1,2,3];
modify-list($test-list);   // returns [99,2,3] but does not mutate original
$test-list;                // prints [1,2,3] original unaffected

modify-list-ref: (
    param $lst-ref: ;
    $lst-ref.1 <: 99;
    return($lst-ref);
);

$test-list-ref: [1,2,3];
modify-list-ref(@test-list-ref);  // returns [99,2,3] and mutates original
$test-list-ref;                    // prints [99,2,3] original affected

//= REFERENCE VS COPY IN LIST OF LISTS ──────────────────────────────────────────────
$list-container: [
    $first: [1,2],
    $second: [3,4]
];

$copy-container: $list-container;        // copy container
$copy-container.first.1 <: 99;
$copy-container;         // prints [$first: [99,2], $second: [3,4]]
$list-container;         // prints [$first: [1,2], $second: [3,4]] original unaffected

$ref-container: @list-container;        // reference container
$ref-container.second.2 <: 88;
$ref-container;          // prints [$first: [1,2], $second: [3,88]]
$list-container;         // prints [$first: [1,2], $second: [3,88]] original affected

//= REFERENCE VS COPY IN FUNCTIONS ──────────────────────────────────────────────────
$number: 10;
copy-increment: (
    param $num: ;
    $num + 1 :> $num;
    return($num);
);

copy-increment($number); // returns 11
$number;                 // prints 10 original unaffected

ref-increment: (
    param $num: ;
    $num + 1 :> $num;
    return($num);
);

ref-increment(@number); // returns 11
$number;                 // prints 11 original affected

//= COPY-BY-DEFAULT WITH FUNCTIONS ────────────────────────────────────────────
$foo-ref1: [$bar: 1];
$foo-ref1;

mutate-bar: (
    param $target: ;
    $target.bar <: 99;
    return($target);
);

// No @ — $foo is copied into the function
$foo-ref1 then mutate-bar($this);   // prints [$bar: 99]
$foo-ref1.bar;                      // still prints 1 — original not mutated

//= REFERENCE PASSING WITH @ ───────────────────────────────────────────────────
$foo-ref2: [$bar: 1];
$foo-ref2;

mutate-bar2: (
    param $target: ;
    $target.bar <: 42;
    return($target);
);

$foo-ref2 then mutate-bar2(@this);  // prints [$bar: 42]
$foo-ref2.bar;                      // prints 42 — original WAS mutated

//= REFERENCE CAPTURE WITHIN A FUNCTION ────────────────────────────────────────
$counter-ref: [
    $count: 10,
    increment: (
        $self.count + 1 :> $self.count;
        return($self.count);
    )
];
$counter-ref.count;             // → 10
$counter-ref.increment();       // → 11
$counter-ref.increment();       // → 12
$counter-ref.count;             // → 12

//= COPY-BY-DEFAULT INSIDE A METHOD ─────────────────────────────────────────────
$counter2: [
    $count: 20,
    increment: (
        $copy: $self;
        $copy.count + 1 :> $copy.count;
        return($copy.count);
    )
];
$counter2.count;             // → 20
$counter2.increment();       // → 21
$counter2.count;             // → still 20 — copy mutated, not self

//= USING $this IN A PIPELINE ───────────────────────────────────────────────────
$goblin-ref: [
    $health: 100,
    take-damage: (
        param $amount: 10;
        $self.health - $amount :> $self.health;
        return($self);
    )
];
$goblin-ref;                   // → [$health: 100]
$goblin-ref.take-damage(15);   // → [$health: 85]
$goblin-ref.health;            // → 85

//= USING EXTERNAL FUNCTION + PIPELINE + @this ────────────────────────────────
take-damage: (
    param $target: ;
    param $amount: 5;
    $target.health - $amount :> $target.health;
    return($target);
);

$orc-ref: [$health: 120];
$orc-ref then take-damage(@this, 20);  // → [$health: 100]
$orc-ref.health;                        // → 100

//= COPY-BY-DEFAULT FAILS TO MUTATE ─────────────────────────────────────────────
$orc-ref2: [$health: 150];
$orc-ref2 then take-damage($this, 25);  // → [$health: 125]
$orc-ref2.health;                       // → 150 — original not mutated

//= SIMPLE BLUEPRINT INSTANTIATION ───────────────────────────────────────────
SimpleGoblin: <[
    health-points: Number,
    position: [Number, Number],
]>;

$simple-goblin-1: SimpleGoblin[
    $health-points: 100,
    $position: [10, 10],
];
$simple-goblin-1;      // prints [$health-points: 100, $position: [10, 10]]

$simple-goblin-2: SimpleGoblin[
    $health-points: 100,
    $position: [10, 15],
];
$simple-goblin-2;      // prints [$health-points: 100, $position: [10, 15]]


//= BLUEPRINT WITH DEFAULTS ────────────────────────────────────────────────
GoblinDefaults: <[
    health-points: 100,
    position: [0, 0],
]>;

$goblin-defaults-1: GoblinDefaults[];
$goblin-defaults-1;            // prints [$health-points: 100, $position: [0, 0]]

$goblin-defaults-2: GoblinDefaults[
    $health-points: 105,
    $position: [11, 15],
];
$goblin-defaults-2;            // prints [$health-points: 105, $position: [11, 15]]

$goblin-defaults-3: GoblinDefaults[
    $position: [10, 10],
];
$goblin-defaults-3;            // prints [$health-points: 100, $position: [10, 10]]


//= BLUEPRINT WITH COMPLEX FIELDS AND FUNCTION ─────────────────────────────
Goblin: <[
    health-points: Number,
    position: [Number, Number],
    attacks: [
        $bite: Number,
        $torch: Number,
],
    status-effect: Text,
]>;

take-damage-blueprint: (
    param $target: ;
    param $damage: 0;
    $target.health-points - $damage :> $target.health-points;
    return($target);
);

$goblin-1: Goblin[
    $health-points: 100,
    $position: [10, 10],
    $attacks: [
        $bite: 50,
        $torch: 40,
],
    $status-effect: "poisoned"
];
$goblin-1;      // prints [$health-points: 100, $position: [10, 10], ...]

$goblin-2: Goblin[
    $health-points: 110,
    $position: [15, 10],
    $attacks: [
        $bite: 55,
        $torch: 35,
   ],
    $status-effect: "none"
];
$goblin-2;      // prints [$health-points: 110, $position: [15, 10], ...]

$goblin-1 then take-damage-blueprint($this, 10) :> $goblin-1;
$goblin-1.health-points;    // prints 90
$goblin-2.health-points;    // prints 110 (unchanged)


//= BLUEPRINT COMPOSITION ──────────────────────────────────────────────────
Animal: <[
    position: [Number, Number, Number],
]>;

Flying-Animal: <[
    wings: "true",
    fly: (
        param $z-position-movement: Number;
        $self.position.3 + $z-position-movement :> $self.position.3;
        return($self);
    )
]>;

Swimming-Animal: <[
    lives-near-water: Text,
    swim: (
        param $x-position-movement: Number;
        param $y-position-movement: Number;
        $self.position.1 + $x-position-movement :> $self.position.1;
        $self.position.2 + $y-position-movement :> $self.position.2;
        return($self);
    )
]>;

Duck: Animal and Flying-Animal and Swimming-Animal;

$donald: Duck[
    $position: [10, 5, 0]
];
$donald.position;            // prints [10, 5, 0]
$donald.fly(5);
$donald.position.3;          // prints 5

Pelican: Animal and Flying-Animal and Swimming-Animal and <[large-mouth: "true"]>;
$pelican: Pelican[
    $position: [0, 0, 0],
    $large-mouth: "true"
];
$pelican.large-mouth;        // prints "true"


//= BLUEPRINT COMPOSITION: CONFLICT ERROR ──────────────────────────────
A: <[x: 1]>;
B: <[x: 2]>;
C: A and B;     // error: duplicate property 'x' in composed blueprints


//= SIMPLE VARIANT GROUP (OPTIONS ONLY) ────────────────────────────────
Magic-Type variants: Fire,
                    or Ice,
                    or Wind,
                    or Earth,
                    or Neutral;

$wizard-attacks: [
    $attack-spell-1: Magic-Type.Fire,
    $attack-spell-2: Magic-Type.Ice,
    $flying-spell: Magic-Type.Wind,
    $magic-shield: Magic-Type.Earth,
    $sword: Magic-Type.Neutral
];
$wizard-attacks.attack-spell-1;   // prints Magic-Type.Fire

$wizard-attacks.bad-spell: Magic-Type.Plasma; // error: 'Plasma' not a valid Magic-Type


//= VARIANTS WITH BLUEPRINTS (SUM-OF-PRODUCTS) ─────────────────────────
Goblin1: <[
    health: Number,
    position: [Number, Number],
    cackle: (
        return("heeheehee");
    )
]>;
Orc1: <[
    health: Number,
    position: [Number, Number],
    shout: (
        return("Manmeat for dinner!");
    )
]>;
Troll1: <[
    health: Number,
    position: [Number, Number],
    bellow: (
        return("RARGH!!!");
    )
]>;

Monster1 variants: Goblin1,
                or Orc1,
                or Troll1;

$enemy1: Monster1.Goblin1[$health: 25, $position: [1,1]];
$enemy2: Monster1.Orc1[$health: 40, $position: [2,2]];

$enemy1.cackle();      // prints "heeheehee"
$enemy2.shout();       // prints "Manmeat for dinner!"


//= VARIANT GROUPING WITH INLINE BLUEPRINTS ────────────────────────────
Monster2 variants:
    Goblin2: <[
        health: Number,
        position: [Number, Number],
        cackle: (
            return("heeheehee");
        )
   ]>,
    or Orc2: <[
        health: Number,
        position: [Number, Number],
        shout: (
            return("Manmeat for dinner!");
        )
   ]>,
    or Troll2: <[
        health: Number,
        position: [Number, Number],
        bellow: (
            return("RARGH!!!");
        )
   ]>;

$foe: Monster2.Troll2[$health: 100, $position: [0,0]];
$foe.bellow();      // prints "RARGH!!!"


//= VARIANTS WITH SHARED BLUEPRINT FIELDS ──────────────────────────────
Monster3 variants:
    Monster3: <[
        health: Number,
        position: [Number, Number]
   ]>,
    and Goblin3: <[
        cackle: (
            return("heeheehee");
        )
   ]>,
    or Orc3: <[
        shout: (
            return("Manmeat for dinner!");
        )
   ]>,
    or Troll3: <[
        bellow: (
            return("RARGH!!!");
        )
   ]>;

$g: Monster3.Goblin3[$health: 7, $position: [8,8]];
$g.cackle();           // prints "heeheehee"
$g.health;             // prints 7

// All three share Monster fields, each gets its own variant behavior

//= USING VARIANTS AS FIELD VALUES IN ANOTHER BLUEPRINT ────────────────
Goblin4 variants:
    Goblin4: <[
        health: Number,
        position: [Number, Number],
        elemental-type: Magic-Type
   ]>,
    and Ice-Goblin: <[
        elemental-type: Magic-Type.Ice
   ]>,
    or Earth-Goblin: <[
        elemental-type: Magic-Type.Earth
   ]>,
    or Normal-Goblin: <[
        elemental-type: Magic-Type.Neutral
   ]>;

$iceg: Goblin4.Ice-Goblin[$health: 10, $position: [2,2]];
$iceg.elemental-type;     // prints Magic-Type.Ice

$normg: Goblin4.Normal-Goblin[$health: 10, $position: [0,0]];
$normg.elemental-type;    // prints Magic-Type.Neutral

//= SIMPLE NAMED DESTRUCTURING ─────────────────────────────
$person1: [
  $name1: "Todd",
  $age1: 27,
  $favorite-color1: "blue"
];

$name1, $age1, $favorite-color1: $person1[];
$name1;            // prints "Todd"
$age1;             // prints 27
$favorite-color1;  // prints "blue"

//= NAMED DESTRUCTURING WITH RENAMING ────────────────────
$person2: [
  $name2: "Todd",
  $age2: 27,
  $favorite-color2: "blue"
];
$name2, $age2, $favorite-color2 -> $shirt-color: $person2[];
$name2;           // prints "Todd"
$age2;            // prints 27
$shirt-color;     // prints "blue"

//= ALTERNATE DIRECTION DESTRUCTURING ────────────────────
$person3: [
  $name3: "Todd",
  $age3: 27,
  $favorite-color3: "blue"
];
$person3[] :> $name3, $age3, $favorite-color3;
$name3;              // prints "Todd"
$age3;               // prints 27
$favorite-color3;    // prints "blue"

//= POSITIONAL DESTRUCTURING ─────────────────────────────
$example-list1: [1, 2, 3];
$x-destruct, $y-destruct, $z-destruct: $example-list1[];
$x-destruct;               // prints 1
$y-destruct;               // prints 2
$z-destruct;               // prints 3

//= HYBRID NAMED+POSITIONAL DESTRUCTURING ────────────────
$person4: [5, $foo4: 6, 7];
$foo4, $bar4, $baz4: $person4[];
$foo4;             // prints 6   (by name)
$bar4;             // prints 5   (first position)
$baz4;             // prints 7   (second position)

//= HYBRID NAMED+POSITIONAL WITH DIFFERENT ORDER ─────────
$person5: [5, $foo5: 6, 7];
$bar5, $foo5, $baz5: $person5[];
$bar5;            // prints 5   (first position)
$foo5;            // prints 6   (by name)
$baz5;            // prints 7   (second position)

//= COPY BY VALUE: CHANGING DESTRUCTURED VARIABLE DOES NOT MUTATE ORIGINAL ──────
$person6: [$name6: "Ali", $age6: 21];
$name6, $age6: $person6[];
"Mo" :> $name6;
22 :> $age6;
$person6.name6;     // prints "Ali"
$person6.age6;      // prints 21
$name6;            // prints "Mo"
$age6;             // prints 22

//= RESTRUCTURING: WRITING BACK TO ORIGINAL ──────────────
$person7: [$name7: "Bea", $age7: 40];
$name7, $age7: $person7[];
"Beatrix" :> $name7;
$age7<: 41;
$person7.name7;     // prints "Bea"
$person7.age7;      // prints 40
$person7[] <: [$name7, $age7];
$person7.name7;     // prints "Beatrix"
$person7.age7;      // prints 41

//= PARTIAL RESTRUCTURING ────────────────────────────────
$person16: [$name16: "Cal", $age16: 19, $color16: "yellow"];
$name16, $age16, $color16: $person16[];
"Calvin" :> $name16;
$person16[] <: [$name16];
$person16.name16;     // prints "Calvin"
$person16.age16;      // prints 19 (unchanged)
$person16.color16;    // prints "yellow"

//= RESTRUCTURING WITH RENAMING ─────────────────────────
$person17: [$age17: 5, $color17: "green"];
$person17[] :> $age17, $color17 -> $fav-color17;
$age17;               // returns 5
$fav-color17;         // returns "green"
[$age17, $fav-color17 -> $color17]:> $person17[];
$person17.color17;    // prints "green"

//= DESTRUCTURING BY REFERENCE: MUTATION PROPAGATES ─────
$person8: [$name8: "Dana", $age8: 50];
@person8[] :> $name8, $age8;
"Dan" :> $name8;
51 :> $age8;
$person8.name8;     // prints "Dan"
$person8.age8;      // prints 51

//= DESTRUCTURING WITH RENAMING BY REFERENCE ─────────────
@person8[] :> $n8, $a8;
"Denise" :> $n8;
$person8.name8;     // prints "Denise"

//= EDGE CASE: AMBIGUOUS DESTRUCTURE (SHOULD ERROR) ─────
$hybrid9: [10, $foo9: 20, 30];
$foo9, $foo9, $bar9: $hybrid9[]; // error: duplicate variable names in destructure

//= EDGE CASE: TOO MANY OR TOO FEW VARIABLES (SHOULD ERROR) ─────────────
$example-list10: [1, 2, 3];
$a10, $b10, $c10, $d10: $example-list10[]; // error: destructure count mismatch
$x10, $y10: $example-list10[]; // this should work and should only destructure the first two list entires by positional index
$x10; // returns 1
$y10; // returns 2

//= DESTRUCTURING OF EMPTY LIST ────────────────────────
$empty11: [];
$a11, $b11: $empty11[]; // error: destructure count mismatch

//= NESTED DESTRUCTURING ──────────────────────────────
$outer12: [ [$x12: 5, $y12: 9], 2 ];
$inner12, $z12: $outer12[];
$inner12.x12;           // prints 5
$inner12.y12;           // prints 9
$z12;                 // prints 2

//= RESTRUCTURING NESTED LIST ─────────────────────────
$inner12.x <: 7;
[$inner12, $z12] :> $outer12[];
$outer12.1.x12;         // prints 7

//= SIMPLE IF TEST
$status-if: "ready";

If $status-if, (
  "Ready!"; // should print "Ready!"
);

//= IF CONDITION NOT MET and not
$status-if-empty: "";

If $status-if-empty, (
  "Won't print"; // shouldn't print
);

If not $status-if-empty, (
  "this should print"; // should print
);

//= ELSE TEST
$status-else: "";

If $status-else, (
  "Won't print";),
Else, (
  "Fallback triggered"; // should print
);

//= NOT CONDITION FALSE
$status-not2: "value";

If not $status-not2, (
  "Won't print";
);

If $status-not2, (
  "this should print";
);

//= IS VALUE MATCH TRUE and False
$color-match: "blue";

If $color-match is "blue", (
  "Matched blue"; // should print
);

If $color-match is "red", (
  "Won't print";
);

//= IS TYPE MATCH TRUE
$val-num: 42;

If $val-num is Number, (
  "It's a number"; // should print
);

//= IS TYPE MATCH FALSE
If $color-match is Number, (
  "Won't print";
);

//= IS EMPTY MATCH
$empty-val: ;

If $empty-val is Empty, (
  "Empty detected"; // should print
);

//= LESS THAN TRUE and FALSE
$num-less: 5;

If $num-less is less than 10, (
  "Less than 10"; // should print
);

If $num-less is less than 3, (
  "Won't print";
);

//= GREATER THAN TRUE and FALSE
$num-greater: 20;

If $num-greater is greater than 10, (
  "Greater than 10"; // should print
);

If $num-greater is greater than 50, (
  "Won't print";
);

//= AT MOST (<=) TRUE and FALSE
$num-at-most: 10;

If $num-at-most is at most 10, (
  "At most 10"; // should print
);

If $num-at-most is at most 9, (
  "Won't print";
);

//= AT LEAST (>=) TRUE and FALSE
$num-at-least: 10;

If $num-at-least is at least 10, (
  "At least 10"; // should print
);

If $num-at-least is at least 20, (
  "Won't print";
);

//= CONTAINS TRUE and FALSE
$list-contain: [1, 2, 3];

If $list-contain contains 2, (
  "Contains 2"; // should print
);

If $list-contain contains 5, (
  "Won't print";
);

//= AND
$status-and: "active";
$count-and: 5;

If $status-and is "active" and $count-and is 5, (
  "Both conditions true"; // should print
);

If $status-and is "inactive" and $count-and is 5, (
  "Won't print";
);

//= OR
If $status-and is "inactive" or $count-and is 5, (
  "At least one true"; // should print
);

If $status-and is "inactive" or $count-and is 10, (
  "Won't print";
);

//= ELSE IF FIRST MATCH
$status-elseif: "first";

If $status-elseif is "first", (
  "First match"; ), // should print
Else if $status-elseif is "second", (
  "Second match";),
Else, (
  "Fallback";
);

//= ELSE IF SECOND MATCH
$status-elseif<: "second";

If $status-elseif is "first", (
  "Won't print";),
Else if $status-elseif is "second", (
  "Second match";),  // should print
Else, (
  "Fallback";
);

//= ELSE IF FALLBACK MATCH
$status-elseif<: "third";

If $status-elseif is "first", (
  "Won't print";),
Else if $status-elseif is "second", (
  "Won't print";),
Else, (
  "Fallback matched"; // should print
);

//= MULTI-BRANCH SWITCH
$switch-val: "B";

If $switch-val either is "A", (
  "A";),
or is "B", (
  "B matched";),  // should print
or is "C", (
  "C";
);

//= MULTI-BRANCH WITH DEFAULT (Otherwise FALLBACK)
$fruit<: "orange";

If $fruit either is "banana", (
  "Banana";),
or is "apple", (
  "Apple";),
Otherwise, (
  "Fallback fruit"; // should print
);

//= MULTI-BRANCH TYPE GUARD MATCHING
$value: 15;

If $value either is Number and is greater than 10, (
  "Big number";),  // should print
or is Number and is at most 10, (
  "Small number";),
Otherwise, (
  "Not a number";
);

//= MULTI-BRANCH TYPE MATCH WITH VARIANT
Magic-Type2 variants: Fire,
                    or Ice,
                    or Wind,
                    or Earth,
                    or Neutral;

$type-val: Magic-Type2.Ice;

If $type-val either is Magic-Type2.Fire, (
  "Fire type";),
or is Magic-Type2.Ice, (
  "Ice type matched";),  // should print
or is Magic-Type2.Wind, (
  "Wind type";),
Otherwise, (
  "Unknown type";
);

//= MULTI-BRANCH CONTAINS MATCH
$bag: ["coin", "key", "map"];

If $bag either contains "sword", (
  "Sword found";),
or contains "key", (
  "Key found";),  // should print
Otherwise, (
  "No useful items";
);

//= MULTI-BRANCH COMPOUND LOGIC
$compound: 3;

If $compound either is Number and is greater than 10, (
  "Big number";),
or is Number and is at most 5, (
  "Small number matched";),  // should print
or is Number, (
  "Number matched";),
Otherwise, (
  "Fallback";
);

//= MULTI-BRANCH LIST EXACT MATCH
$list-exact: [1,2,3];

If $list-exact either is [3,2,1], (
  "Reverse matched";),
or is [1,2,3], (
  "Exact List matched";),  // should print
Otherwise, (
  "No exact List match";
);

//= MULTI-BRANCH WITH VARIANT GROUP
Monster-Branch variants: Goblin, or Orc, or Troll;

$monster-type1: Monster-Branch.Goblin;

If $monster-type1 either is Monster-Branch.Orc, (
    "Orc matched";),
  or is Monster-Branch.Goblin, (
    "Goblin matched";),  // should print
  or is Monster-Branch.Troll, (
    "Troll matched";),
  Otherwise, (
    "No monster match";
);

//= INLINE IF TRUE and FALSE
$inline-if: "ready";
If $inline-if, ( "Go!"); // prints "Go!"
$inline-if<: "";
If $inline-if, ("Go!"), Else, ("Wait!"); // prints "Wait!"

//= BOOLEAN EDGE CASE FALSE CONDITIONS
If 0, ("Won't print1");
If "", ("Won't print2");
If [], ("Won't print3");
If [0,0,0], ("Won't print4");
If False, ("Won't print5");
If Status.False, ("Won't print6");
If not 0, ("will print");
If not "", ("will print");
If not [], ("will print");
If not [0,0,0], ("will print");
If not False, ("will print");
If not Status.False, ("will print");

//= BOOLEAN EDGE CASE TRUE CONDITIONS
If Monster-Branch, ("True variant group"); // prints
If Monster-Branch.Goblin, ("True variant value"); // prints
If "hi", ("True text atom"); // prints

//= Function Atom as condition
If ( ), ("Won't print1"); // empty function atom shouldn't trigger

If (4 + 5), ("Will print"); // function with value should trigger

If (5 - 5), ("Won't print2"); // function returns 0 which is a false condition

If not (5 - 5), ("Will print"); // function returns 0 which is a false condition

//= IF WITH FUNCTION RETURNING EMPTY (FALSY)
empty-fn-test: ();

If empty-fn-test(), (
  "Won't print";),
Else, (
  "Empty function result"; // should print
);

//= IF WITH FUNCTION RETURNING NON-EMPTY (TRUTHY)
non-empty-fn-test: ("result";);

If non-empty-fn-test(), (
  "Non-empty function result"; // should print
);

//= IF WITH VARIABLE SET TO EMPTY LIST THEN MUTATED TO TRUTHY LIST
$list-mutate: [];

If $list-mutate, (
  "Won't print initially";
);

$list-mutate <: [1];

If $list-mutate, (
  "List became truthy"; // should print
);

//= IF WITH VARIABLE SET TO TEXT "0" (TRUTHY)
$text-zero: "0";

If $text-zero, (
  "Text '0' is truthy"; // should print
);

//= IF WITH VARIABLE SET TO NUMBER 0.0 (FALSY)
$num-zero: 0.0;

If $num-zero, (
  "Won't print"),
Else, (
  "0.0 is falsy"; // should print
);

//= IF WITH EMPTY BLUEPRINT INSTANCE (TRUTHY)
EmptyBP: <[]>;
$empty-bp: EmptyBP[];
If $empty-bp, (
  "Empty blueprint is falsy"),  // shouldn't print
Else, (
  "Empty blueprint is falsy!";  //should print
);

//= IF WITH VARIABLE SET TO STATUS.FALSE THEN MUTATED TO CUSTOM STATUS (TRUTHY)
$status-custom: Status.False;
If $status-custom, (
  "Won't print initially";
);

Status variants include Loading, or Dead;

$status-custom <: Status.Loading;

If $status-custom, (
  "Custom status is truthy"; // should print
);

//= MULTI-BRANCH MATCH WITH SECOND TRUTHY MATCH
$multi-branch: "second";

If $multi-branch either is "first", (
  "First matched"),  // shouldn't print
or is "second", (
  "Second matched";
);

//= MULTI-BRANCH MATCH WITH MULTIPLE TRUTHY CONDITIONS, ONLY FIRST EXECUTES
$multi-branch-num: 10;

If $multi-branch-num either is at least 5, (
  "At least 5 matched"),  // should print
or is Number, (
  "Generic number matched (shouldn't print)";
);

//= MULTI-BRANCH MATCH WITH MULTIPLE TRUTHY CONDITIONS, ALL EXECUTE
$multi-branch-num1: 10;

If $multi-branch-num1 is at least 5, (
  "At least 5 matched"),  // should print
or is Number, (
  "generic number should print"; // should print
);

//= ERROR CASE: USING UNDEFINED VARIABLE IN IF
If $undefined-var, ( // error: undefined variable
  "Won't print";
);

//= ERROR CASE: INVALID COMPARISON TYPE
If $list-contain is less than 10, ( // error: can't compare List with Number comparison word
  "Won't print";
);

//= ERROR CASE: INVALID USE OF "CONTAINS" ON NON-LIST
$non-list-val: 10;

If $non-list-val contains 1, ( // error: contains used on non-List
  "Won't print";
);

//= ERROR CASE: INVALID MULTI-BRANCH "or" WITHOUT PRECEDING IF
or "value", ( // error: `or` without preceding `If`
  "Won't print";
);

//= ERROR CASE: ELSE IF WITHOUT INITIAL IF
Else if $color is "blue", ( // error: `Else if` without preceding `If`
  "Won't print";
);

//= ERROR CASE: ELSE WITHOUT INITIAL IF
Else, ( // error: `Else` without preceding `If`
  "Won't print";
);

//= BOOLEAN TEST: LIST WITH ALL FALSY ELEMENTS
$list-all-falsy: [0, "", [], False];

If $list-all-falsy, (
  "won't print"; // shouldn't print
);

If not $list-all-falsy, (
  "All falsy elements in a List are falsy"; // should print
);

//= BOOLEAN TEST: TEXT WITH WHITESPACE ONLY (TRUTHY)
$text-whitespace: "   ";

If $text-whitespace, (
  "Whitespace text is truthy"; // should print
);

//= BOOLEAN TEST: VARIABLE WITH EMPTY BLUEPRINT VARIANT (TRUTHY)
EmptyVariantBP variants: Empty, or Filled;

$empty-variant: EmptyVariantBP.Empty;

If $empty-variant, (
  "Empty variant is truthy"; // should print
);

//= BOOLEAN TEST: EMPTY PARAMETERIZED FUNCTION (FALSY)
$empty-param-fn: (param $x: ;);

If $empty-param-fn, (
  "Won't print"),
Else, (
  "Empty parameterized function is falsy"; // should print
);

//= INLINE IF WITH VARIABLE SET TO NUMBER 1 (TRUTHY)
$inline-num: 1;

If $inline-num, ("Number 1 is truthy"), Else, ("Won't print"); // prints truthy

//= INLINE IF WITH EMPTY LIST (FALSY)
$inline-list: [];

If $inline-list, ("Won't print"), Else, ("Empty List falsy"); // prints falsy

//= DESTRUCTURE IN IF CONDITION (Truthy)
$person21: [$name21: "Eve", $age21: 28];
$name21, $age21: $person21[];

If $age21 is greater than 21, (
  "<$name21> is over 21"; // should print "Eve is over 21"
);

//= DESTRUCTURING BY REFERENCE AND MUTATION IN CONTROL FLOW
$player21: [$hp21: 50, $status21: "alive"];

@player21[] :> $hp21, $status21;

If $hp21 is less than 100, (
  100 :> $hp21; // mutate referenced destructured variable
);

$player21.hp; // should now be 100

//= MULTI-STAGE PIPELINE WITH CONDITIONAL STEP ERROR
$list-pipe: [1,2,3,4];

$list-pipe
then ($this contains 4) :> $contains-four;  // error: comparison word in pipeline

//= Has function and pipeline
has1: (
  param $list: ;
  param $value: ;

  If $list contains $value, (return(True)), Else,  (return(False));
);

$list-pipe22: [1,2,3,4];

$list-pipe22 then has1($this, 4) :> $contains-four22;

If $contains-four22, (
  "List contains four"; // should print
);

//= IF CONDITION WITH LIST INDEX ACCESS
$list-index23: ["zero", "one", "two"];

If $list-index23.2 is "one", (
  "Second index matched 'one'"; // should print
);

If $list-index23.3 is "one", (
  "Won't print"),
Else, (
  "Third index is not 'one'"; // should print
);

//= LIST MAPPING WITH CONTROL FLOW CONDITION
$user-map: [$username: "alice", $active: "yes"];

If $user-map.active is "yes", (
  "<$user-map.username> is active"; // should print "alice is active"
);

//= LIST MAPPING AND PIPELINE INTO CONTROL FLOW
$user-map
then ($this.active) :> $is-active;

If $is-active is "yes", (
  "User active status: yes"; // should print
);

//= BLUEPRINT DEFAULTS IN CONTROL FLOW
Character: <[$hp: 100, $mana: 50]>;

$hero: Character[];

If $hero.hp is at least 100, (
  "Hero at full health"; // should print
);

//= ERROR: IF CONDITION ACCESSING INVALID LIST INDEX
$bad-list50: [1,2,3];

If $bad-list50.4, ( // error: List index out of range
  "Won't print";
);

//= ERROR: IF CONDITION ON UNDEFINED PROPERTY IN LIST
$user-bad: [$name: "Bob"];

If $user-bad.age, ( // error: List property `$age` not found
  "Won't print";
);

//= More destructuring stuff and conditionals stuff
$nums29: [5,6,7];

$x29, $y29, $z29: $nums29[];

If $x29 is 5 and $y29 is 6 and $z29 is 7, ("Pass: positional destructure");

//= multiple statements in an inline if
If True, ("passing one statement from inline If"; "passing a second one"); // prints both lines

If True, ($inline-value: 5; $inline-value);  // prints 5

If False, ("this shouldn't print"), Else, ($inline-value2: 6; $inline-value2;);  // prints 6

//= IF WITH NESTED CONDITIONALS
$status-nested: "outer";

If $status-nested is "outer", (
  If $status-nested, (
    "Nested condition true"; // should print
  );
);

//= PIPELINE WITH INLINE FUNCTION RETURNING EMPTY (FALSY)
empty-fn-pipeline: ();

empty-fn-pipeline() then ($this) :> $pipeline-empty;

If not $pipeline-empty, (
  "Pipeline resulted in empty"; // should print
);

//= BOOLEAN TEST: NESTED LIST WITH TRUTHY AND FALSY ELEMENTS
$nested-list66: [0, "", [0, "valid"]];

If $nested-list66, (
  "Nested List considered truthy"; // should print
);

//= ERROR: USING "is" WITH A VARIANT THAT DOES NOT EXIST
If $status-bp is StatusVariantBP.Unknown, (// error: undefined variable
  "Won't print";
);

//= Conditional pipelining
$goblinoid: [
  $health: 30,
  $status: "alive"
];

take-damage1: (
  param $target: ;
  param $damage: 0;
  $target.health - $damage :> $target.health;
  return($target);
);

set-status: (
  param $target: ;
  param $status: "";
  $status :> $target.status;
  return($target)
);

$goblinoid
  then take-damage1($this, 30)
    then If $this.health is less than 1, (
        set-status($this, "dead")
    )
  :> $goblinoid;

$goblinoid.health;  // should print 0
$goblinoid.status;  // should print "dead"

//= IF CONDITION WITH NESTED LIST INDEX ACCESS
$nested-list: [["zero", "one"], ["two", "three"]];

If $nested-list.2.1 is "two", (
  "Nested index matched 'two'"; // should print
);

//= COMPUTED INDEX: BASIC ADDITION
$list100: [10, 20, 30, 40];
$x100: 2;
$list100.($x100 + 1);        // prints 30 (index 3)

//= COMPUTED INDEX: WITH LITERAL ARITHMETIC
$list200: [100, 200, 300];
$list200.(1 + 2);           // prints 300 (index 3)
$list200.(2 * 1);           // prints 200 (index 2)

//= COMPUTED INDEX: WITH NESTED EXPRESSIONS
$a00: 1;
$b00: 2;
$list200.($a00 + $b00);         // prints 300 (index 3)
$list200.($a00 + ($b00 * 1));   // prints 300 (index 3)

//= COMPUTED INDEX: NEGATIVE AND ZERO
$list300: [5, 10, 15];
$list300.($a00 - 1);          // error: List index out of range (if $a = 1)
$list300.(-1 + 2);          // prints 5 (index 1)
$list300.(-2 + 4);          // prints 10 (index 2)
$list300.(-1);              // error: List index out of range

//= COMPUTED INDEX: OUT OF BOUNDS
$list300.(4);               // error: List index out of range (List has 3 elements)
$list300.($a00 + $b00 + 2);     // error: List index out of range

//= COMPUTED INDEX: NON-INTEGER RESULT
$list400: [9, 8, 7];
$list400.(1.5);             // error: List index must be integer
$list400.($a00 / 2);          // error: List index must be integer

//= COMPUTED INDEX: INVALID EXPRESSION TYPE
$list400.("hi");            // error: List index must be integer
$list400.($list100);          // error: List index must be integer

//= COMPUTED INDEX: USE IN ASSIGNMENT
$list500: [10, 20, 30];
$i00: 1;
99 :> $list500.($i00 + 1);    // sets $list5.2 to 99
$list500.2;                 // prints 99

//= COMPUTED INDEX: USE IN PIPELINE
$list500 then ($this.($i00 + 2)); // prints 30 (index 3)

//= COMPUTED INDEX: INDEX BY FUNCTION RETURN (optional, if supported)
idx-fn00: (return(2));
$list500.(idx-fn00());         // prints 99 (index 2)

//= COMPUTED INDEX: VARIABLE SHADOWING
$j00: 3;
$list500.($j00);               // prints 30 (index 3)

//= COMPUTED INDEX: IN INTERPOLATION
$msg00: "Element is <$list500.($i00 + 1);>";
$msg00;                      // prints "Element is 99"

//= Basic loop: 1 time
$loop-iteration: 0;
Loop, (
    $loop-iteration + 1 :> $loop-iteration;
    "There have been <$loop-iteration> loop iterations";
    end-loop;
); // prints one time

//= Basic loop: 3 times
$loop-iteration<: 0;
Loop, (
    $loop-iteration + 1 :> $loop-iteration;
    "There have been <$loop-iteration> loop iterations";

    If $loop-iteration is at least 3, (
        end-loop;
    );
); // prints 3 times

//= LOOP WITH SKIP ON CONDITION
$loop-iteration<: 0;
Loop, (
    $loop-iteration + 1 :> $loop-iteration;
    If ($loop-iteration % 2) is 0, (
        // silent on even numbers
        restart-loop;
    );
    $loop-iteration; // prints odd numbers

    If $loop-iteration is at least 9, (
        end-loop;
    );
); // prints odd numbers 1-9


//= SIMPLE LOOP: INCREMENT INSIDE, BREAKS AFTER 5
$j-loop: 1;
Loop, (
  $j-loop;             // should print 1, 2, 3, 4, 5
  If $j-loop is 5, ( end-loop; );
  $j-loop + 1 :> $j-loop;
);

//= Loop function atom shadowing
$loop-temp: 0;
$loop-temp;  // prints 0
Loop, (
    $loop-temp: 10;  // not an error because this is within a function atom and can shadow
    $loop-temp; // prints 10
    end-loop;
);

$loop-temp; // prints 0 because outer variable remains unchanged by declaration.

Loop, (
    $loop-temp<: 11;  // this should rebind the outer variable, there is no shadowing here
    $loop-temp; // prints 11
    end-loop;
);

$loop-temp; // returns 11

//= Multi iteration loops with fresh shadow scope
$loop-iteration1: 0;
$local-var: 5;
$local-var; // prints 5
Loop, (
    $local-var: 1; // shadows the exterior local var
    $local-var; // prints 1 each loop
    $local-var + 1 :> $local-var;
    $local-var; // prints 2 each loop
    $loop-iteration1 + 1 :> $loop-iteration1;  // This would not shadow the exterior scope, so the value would be persistent
    $loop-iteration1; // prints 1, 2, 3
   If $loop-iteration1 is at least 3, (end-loop); //
);

$local-var; // prints 5, unchanged by loop shadowing



//= Not a loop error
(
    "this function atom is not a loop";
    end-loop; // error: `end-loop;` inside a non-loop function atom
);

(
    "this function atom is not a loop";
    restart-loop; // error: `restart-loop;` inside a non-loop function atom
);

//= ERROR: UNDECLARED VARIABLE USED INSIDE LOOP
Loop, (
    $undefVar-loop;      // error: undefined variable
    end-loop;
);

//= LOOP: PIPELINING IN LOOP BODY
$p-loop: 1;
Loop, (
    $p-loop then ($this * 2) :> $p-loop;
    If $p-loop is greater than 10, ( end-loop; );
);
$p-loop; // should print 16

//= WHILE LOOP SIMPLE
$count-while: 1;
Loop while $count-while is less than 3, (
  $count-while;
  $count-while <: $count-while + 1;
);
$count-while; // prints 3

//= WHILE LOOP NEVER ENTERED (INITIAL CONDITION FALSE)
$count-never: 5;
Loop while $count-never is less than 0, (
  "Never prints";
  $count-never <: $count-never - 1;
);

$count-never; // prints 5, unchanged

//= SIMPLE FOR LOOP
$list-for: [1,2,3];
Loop for $item in $list-for, (
  "Item: <$item>"; // prints each item
);

//= FOR LOOP WITH EMPTY LIST (NEVER ENTERED)
$empty-list-for: [];
Loop for $item in $empty-list-for, (
  "Never prints";
);

$empty-list-for; // prints []

//= ERROR: FOR LOOP WITH NON-ITERABLE
$item10: 5;
Loop for $item10 in 10, ( // error: `for` loop must be over a List
  "Won't print";
);

//= WHILE LOOP WITH COMPLEX CONDITION
$active-while: True;
$counter-while: 0;
Loop while $active-while and $counter-while is less than 5, (
    $counter-while + 1 :> $counter-while;
    "Counter: <$counter-while>"; // prints 1, 2, 3, 4, 5

    If $counter-while is 5, (
        False :> $active-while;
    );
);
$active-while; // should print False

//= UNTIL LOOP: THE OPPOSITE OF WHILE
$count-until: 0;
Loop until $count-until is 3, (
  "Count is <$count-until>"; // prints for 0, 1, 2
  $count-until + 1 :> $count-until;
);
$count-until; // should print 3

//= UNTIL LOOP THAT NEVER RUNS
$never-run-until: 10;
Loop until $never-run-until is greater than 5, (
    "This should not execute";
);
$never-run-until; // prints 10, unchanged

//= FOR LOOP: ITEM IS A COPY, NOT A REFERENCE
$list-for-copy: [10, 20, 30];
Loop for $item in $list-for-copy, (
  $item <: $item + 1; // Mutating the loop variable
  "Item copy is now <$item>"; // prints 11, 21, 31
);
$list-for-copy; // prints [10, 20, 30] - original List is unaffected

//= FOR LOOP: ITEM IS A REFERENCE
$list-for-copy2: [10, 20, 30];
Loop for @item in $list-for-copy2, (
  $item <: $item + 1; // Mutating the original variable
  "Item is now <$item>"; // prints 11, 21, 31
);
$list-for-copy2; // prints [11, 21, 31] - original List has changed

//= WHILE LOOP MUTATING THE ORIGINAL LIST (BY INDEX)
$list-for-mutate: [10, 20, 30];
$i-for: 1;
Loop while $i-for is at most 3, (
    $list-for-mutate.$i-for + 5 :> $list-for-mutate.$i-for;
    $i-for + 1 :> $i-for;
);

$list-for-mutate; // prints [15, 25, 35] - original is mutated

//= WHILE LOOP SHADOWING
$iteration52: 0;
$iteration52; // prints 0
Loop while $iteration52 is less than 3, (
    $local-var: 1;
    $local-var;  // prints 1 each loop
    $local-var + 1 :> $local-var;
    $local-var; // prints 2 each loop
    $iteration52 + 1 :> $iteration52;
    $iteration52; // prints 1, 2, 3
);

$iteration52; // prints 3

//= While loop shadowing exception

$iteration53: 0;
$iteration53; // prints 0
$local-var2: 0;
$local-var2; // prints 0
Loop while $iteration53 is less than 3, (
    $local-var2: 1;
    $local-var2;  // prints 1 each loop
    $local-var2 + 1 :> $local-var2;
    $local-var2; // prints 2 each loop
    $iteration53 + 1 :> $iteration53;
    $iteration53; // prints 1, 2, 3
);
$iteration52; // prints 3
$local-var2; // prints 0

//= FOR LOOP OVER LIST OF LISTS
$list-of-lists: [[1, 2], ["a", "b"]];
Loop for $inner in $list-of-lists, (
    "Inner List: <$inner>"; // prints [1, 2] then ["a", "b"]
    $inner.1; // prints 1, then "a"
);

//= FOR LOOP WITH DESTRUCTURING INSIDE
$people: [
    [$name: "Alice", $age: 30],
    [$name: "Bob", $age: 42]
];
Loop for $person in $people, (
    $name, $age: $person[];
    "User <$name> is <$age> years old."; // prints for Alice, then Bob
);

//= USING RESTART-LOOP AND END-LOOP
$numbers-for: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
$sum-for: 0;
Loop for $num in $numbers-for, (
    If $num is 8, (
        "Found 8, ending loop.";
        end-loop;
    );
    If ($num % 2) is not 0, (
        // skip odd numbers
        restart-loop;
    );
    $sum-for + $num :> $sum-for; // only adds even numbers
);
$sum-for; // should be 2 + 4 + 6 = 12

//= MODIFYING THE LIST WHILE ITERATING (APPENDING)
$dynamic-list: [1, 2];
$iterations-dynamic: 0;
Loop for $item in $dynamic-list, (
    "Item: <$item>"; // should print 1, 2, 3
    $iterations-dynamic + 1 :> $iterations-dynamic;
    If $item is 2, (
        [<$dynamic-list>, 3] :> $dynamic-list; // append to the List
    );
    If $iterations-dynamic is 3, ( end-loop; ); // safety break
);
$dynamic-list; // should be [1, 2, 3]

//= MODIFYING AN UPCOMING ITEM
$items-live: ["a", "b", "c"];
Loop for $item in $items-live, (
  "Current item: <$item>"; // prints "a", then "b_mod", then "c"
  If $item is "a", (
    "b_mod" :> $items-live.2; // Modify the next item in the List
  );
);
$items-live; // prints ["a", "b_mod", "c"]

//= ITERATING OVER BLUEPRINT INSTANCES
Player: <[ name: Text, hp: Number ]>;
$players: [
    Player[$name: "Zork", $hp: 100],
    Player[$name: "Bork", $hp: 85]
];
Loop for $p in $players, (
    If $p.hp is less than 100, (
        "<$p.name> needs healing!";
    );
);

//= END-LOOP AFFECTS INNERMOST LOOP ONLY
Loop, (
    "Outer loop started";
    $inner-count: 0;
    Loop, (
        "Inner loop running";
        $inner-count + 1 :> $inner-count;
        If $inner-count is 1, (
                "ending inner loop";
                end-loop; // should only end the inner loop
        );
    );
    "Inner loop finished";
    end-loop; // end the outer loop
    "shouldn't print";
);

//= RESTART-LOOP AFFECTS INNERMOST LOOP ONLY
$matrix: [[1, 2], [3, 4]];
Loop for $row in $matrix, (
    "Processing row: <$row>";
    Loop for $cell in $row, (
        If $cell is 3, (
            "Found 3, restarting inner loop";
            restart-loop; // skips printing 3
        );
        "Cell: <$cell>"; // prints 1, 2, 4
    );
);

//= LOOP INSIDE A FUNCTION WITH A RETURN
find-first-even: (
    param $list: [];
    Loop for $item in $list, (
        If ($item % 2) is 0, (
            return($item); // should exit the loop AND the function
        );
    );
    return(False); // if no even number is found
);
find-first-even([1, 3, 5, 8, 9]); // prints 8
find-first-even([1, 3, 5, 7, 9]); // prints False

//= FOR LOOP (LIVE): DELETING AN ITEM BEHIND THE ITERATOR
$list-delete-behind: ["a", "b", "c"];
$visited-behind: [];
Loop for $item in $list-delete-behind, (
  // When $item is "b", we delete "a". The List becomes ["b", "c"].
  // The iterator's next position is index 3, which is now "c".
  // This behavior can be surprising but is consistent with a live index.
  If $item is "b", (
      [$list-delete-behind.2, $list-delete-behind.3] :> $list-delete-behind;
  );
  [<$visited-behind>, $item] :> $visited-behind;
);
$visited-behind; // Should print ["a", "b", "c"]
$list-delete-behind; // Should print ["b", "c"]

//= FOR LOOP (LIVE): DELETING THE CURRENT ITEM AND SKIPPING THE NEXT
$list-delete-current: ["a", "b", "c", "d"];
$visited-current: [];
Loop for $item in $list-delete-current, (
    [<$visited-current>, $item] :> $visited-current;
    If $item is "b", (
        // List becomes ["a", "c", "d"]. The iterator was at index 2.
        // For the next iteration, it moves to index 3. The item at index 3 is now "d".
        // The value "c" is effectively skipped. This is a critical behavior to define.
        [$list-delete-current.1, $list-delete-current.3, $list-delete-current.4] :> $list-delete-current;
    );
);
$visited-current; // prints ["a", "b", "d"]
$list-delete-current; // prints ["a", "c", "d"]

//= FOR LOOP (LIVE): CLEARING THE LIST MID-ITERATION
$list-clearing: [10, 20, 30, 40];
$visited-clearing: [];
Loop for $item in $list-clearing, (
    [<$visited-clearing>, $item] :> $visited-clearing;
    If $item is 20, (
        [] :> $list-clearing; // Clear the List
    );
);
$visited-clearing; // prints [10, 20]. The loop terminates as the List is now empty.
$list-clearing; // prints []

//= FOR @ITEM: MUTATING PROPERTIES OF BLUEPRINT INSTANCES
$monsters55: [
    Player[$name: "Goblin", $hp: 20],
    Player[$name: "Orc", $hp: 50]
];
Loop for @monster in $monsters55, (
    // Rebind the hp property of the original monster in the List
    $monster.hp + 10 :> $monster.hp;
);
$monsters55.1.hp; // prints 30
$monsters55.2.hp; // prints 60

//= FOR @ITEM: REBINDING AN ENTIRE ELEMENT TO A NEW INSTANCE
Loop for @monster_ref in $monsters55, (
    // Replace the Orc with a brand new, full-health Player
    If $monster_ref.name is "Orc", (
        Player[$name: "Super Orc", $hp: 100] :> $monster_ref;
    );
);
$monsters55; // prints [Player[$name: "Goblin", $hp: 30], Player[$name: "Super Orc", $hp: 100]]

//= FOR @ITEM: ERROR ON TYPE-INCONSISTENT REBINDING
$typed_list: [10, 20];
Loop for @num_ref in $typed_list, (
    If $num_ref is 20, (
        "should not work" :> $num_ref; // error: cannot bind Text to Number
    );
);

//= NESTED LOOPS: SHADOWING THE LOOP VARIABLE
$outer-list: [1, 2];
$inner-list: ["a", "b"];
Loop for $item in $outer-list, (
  "Outer: <$item>";
  Loop for $item in $inner-list, (
    // This is allowed. The inner '$item' shadows the outer one.
    "Inner: <$item>";
  );
  "Outer again: <$item>"; // The outer $item is visible again (value 1, then 2)
);

//= FOR LOOP OVER A LIST CONTAINING EMPTY/FALSY VALUES
$mixed-falsy-list: [1, "", 3, False, 5];
$visited-falsy: [];
Loop for $val in $mixed-falsy-list, (
  // The loop should visit every element, regardless of its truthiness
  [<$visited-falsy>, $val] :> $visited-falsy;
);
$visited-falsy.2; // should be "" (empty string)
$visited-falsy.4; // should be False

//= ERROR: USING `end-loop` IN A PIPELINE
Loop, (
    1 then (end-loop;); // error: `end-loop;` inside a non-loop function atom
    end-loop;
);

//= LOOPING OVER A REFERENCE TO A LIST
$original-list-ref: ["x", "y", "z"];
$ref-to-list: @original-list-ref;
$visited-ref-list: [];
// This should behave identically to looping over the original
Loop for $item in $ref-to-list, (
    [<$visited-ref-list>, $item] :> $visited-ref-list;
);
$visited-ref-list; // prints ["x", "y", "z"]

//= WHILE LOOP WITH END-LOOP
$counter45: 0;
$counter45; // prints 0
Loop while $counter45 is less than 10, (
    $counter45 + 1 :> $counter45;
    $counter45;
    If $counter45 is 3, (end-loop;);
);
$counter45; // Should print 3

//= WHILE LOOP WITH RESTART-LOOP
$i-99: 0;
$processed-99: 0;
Loop while $i-99 is less than 5, (
    $i-99 + 1 :> $i-99;
    If $i-99 is 3, (restart-loop;); // Skip processing when i=3
    $processed-99 + 1 :> $processed-99;
    $processed-99;
);
$i-99; // print 5
$processed-99; // Should print 4 (skipped when i=3)

//= UNTIL LOOP WITH END-LOOP
$value-loop: 1;
Loop until $value-loop is 100, (
    $value-loop * 2 :> $value-loop;
    $value-loop;
    If $value-loop is 16, (end-loop;);
);
$value-loop; // Should print 16

//= UNTIL LOOP WITH RESTART-LOOP
$attempts: 0;
$success: 0;
Loop until $success is 3, (
    $attempts + 1 :> $attempts;
    If $attempts is 2, (restart-loop;); // Skip this attempt
    $success + 1 :> $success;
    $success;
);
$attempts;   // should print 4
$success; // Should print 3

//= FOR LOOP WITH END-LOOP
$numbers: [1, 2, 3, 4, 5];
Loop for $num in $numbers, (
    $num;
    If $num is 3, (end-loop;);
);
// Should print: 1, 2, 3

//= FOR LOOP WITH RESTART-LOOP
$items: [1, 2, 3, 4, 5];
Loop for $item in $items, (
    If $item is 3, (restart-loop;); // Skip 3
    "Processing: <$item;>";
);
// Should print: "Processing: 1", "Processing: 2", "Processing: 4", "Processing: 5"

//= FOR LOOP WITH REFERENCE AND END-LOOP
$data: [10, 20, 30, 40];
Loop for @ref in $data, (
    $ref;
    If $ref is 30, (end-loop;);
);
$data; // Should print [10, 20, 30, 40] (unchanged)

//= WHILE LOOP WITH BOTH END-LOOP AND RESTART-LOOP
$x-77: 0;
$results-77: [];
Loop while $x-77 is less than 10, (
    $x-77 + 1 :> $x-77;
    If $x-77 is 3, (restart-loop;); // Skip 3
    If $x-77 is 7, (end-loop;);     // Stop at 7
    [<$results-77>, $x-77] :> $results-77;
);
$results-77; // Should be [1, 2, 4, 5, 6]

//= FOR LOOP ERROR: END-LOOP IN NESTED FUNCTION
$list-93: [1, 2, 3];
Loop for $item in $list-93, (
    (end-loop;); // error: `end-loop;` inside a non-loop function atom
);

//= LIST INTERPOLATION: BASICS
$li1: [1, 2, 3];
$li2: [4, 5];
$li3: [<$li1>, <$li2>];
$li3; // should return [1, 2, 3, 4, 5]

//= LIST INTERPOLATION: PREPEND
$li4: [10, 11, 12];
[0, <$li4>] :> $li4;
$li4;                         // should return [0, 10, 11, 12]

//= LIST INTERPOLATION: APPEND
$li5: ["a", "b"];
$li5 <: [<$li5>, "c"];
$li5;                         // should return ["a", "b", "c"]

//= LIST INTERPOLATION: NESTED INTERPOLATION
$li6: [1, 2];
$li7: [3, 4];
$li8: [<$li6>, [<$li7>]];     // should return [1, 2, [3, 4]]
$li8;

//= LIST INTERPOLATION: INSERTION
$li9: [100, 200];
$li10: [0, <$li9>, 300];
$li10;                        // should return [0, 100, 200, 300]

//= LIST INTERPOLATION: MULTIPLE INTERPOLATIONS IN ONE LIST
$li11: [1, 2];
$li12: [3, 4];
$li13: [<$li11>, <$li12>, 5];
$li13;                        // should return [1, 2, 3, 4, 5]

//= LIST INTERPOLATION: EMPTY LISTS
$li14: [];
$li15: [<$li14>];
$li15;                        // should return []

//= LIST INTERPOLATION: EMPTY IN NON-EMPTY LIST
$li16: [<$li14>, 99];
$li16;                        // should return [99]

//= LIST INTERPOLATION: SINGLE NON-LIST VALUE (should just insert value)
$li17: [42];
$li18: [<$li17>, 99];
$li18;                        // should return [42, 99]

//= LIST INTERPOLATION: INTERPOLATION OF NON-LIST VALUE (should error)
$notalist-interp: 42;
$li19: [<$notalist-interp>];         // should error: cannot interpolate non-list into a list

//= LIST INTERPOLATION: NESTED LISTS (non-interpolated, for comparison)
$li20: [1, 2];
$li21: [3, 4];
$li22: [$li20, $li21];
$li22;                        // should return [[1, 2], [3, 4]]

//= LIST INTERPOLATION: TRAILING/LEADING INTERPOLATION
$li23: [5, 6];
$li24: [<$li23>];
$li24;                        // should return [5, 6]
$li25: [<$li23>, ];
$li25;                        // should return [5, 6]

//= LIST INTERPOLATION: APPEND TO EMPTY LIST
$li26: [];
$li26 <: [<$li23>];
$li26;                        // should return [5, 6]

//= LIST INTERPOLATION: WITH TEXTS AND MIXED TYPES
$li27: ["apple", "banana"];
$li28: [1, <$li27>, "pear"];
$li28;                        // should return [1, "apple", "banana", "pear"]

//= LIST INTERPOLATION: MULTIPLE EMPTY LISTS
$li29: [<$li14>, <$li14>];
$li29;                        // should return []

//= LIST INTERPOLATION: ERROR IF INTERPOLATING UNDEFINED VARIABLE
$li30: [<$does_not_exist>];   // should error: undefined variable

//= LIST INTERPOLATION: INTERPOLATING A BLUEPRINT INSTANCE (should insert as value)
BP-example: <[foo: Number]>;
$bp1: BP-example[$foo: 10];
$li31: [<$bp1>];              // should error: cannot interpolate non-list into a list

//= PIPELINE INTERPOLATE
$li32: [1, 2, 3];
$li33: [$li32 then ($this), 99]; // should return [[1, 2, 3], 99]
$li33;
$li34: [<$li32 then ($this)>, 99]; // should return [1, 2, 3, 99]
$li34;

//= SHADOWING: VARIABLE IN `If` BLOCK SHADOWS GLOBAL
$cond-shadow-global: "global";
If True, (
    $cond-shadow-global: "if-shadow"; // This declares a NEW $cond-shadow-global, scoped only to this block.
    "Inside If: <$cond-shadow-global>"; // Should print "if-shadow"
);
"Outside If: <$cond-shadow-global>"; // The global $cond-shadow-global is unaffected. Should print "global"

//= REBINDING: MODIFYING GLOBAL VARIABLE FROM `If` BLOCK
If True, (
    $cond-shadow-global <: "shadowing it using rebind"; // This REBINDS the existing outer $cond-shadow-global. No shadowing.
    "Inside If: <$cond-shadow-global>"; // Should print "shadowing it using rebind"
);
"Outside If: <$cond-shadow-global>"; // The global $cond-shadow-global was mutated.

//= SCOPE LEAKAGE: VARIABLE DECLARED IN `If` IS UNDEFINED OUTSIDE
If True, (
    $z-local: "local-to-if"; // This $z-local only exists inside this block's scope.
);
$z-local; // error: undefined variable

//= SCOPE ISOLATION: `If` AND `Else` BLOCKS HAVE SEPARATE SCOPES
$scope-test: "global";
If False, (
    $scope-test: "if-branch"; // This block is not entered.
    $if-var: 1;
), Else, (
    $scope-test: "else-branch"; // Shadows the global variable.
    "In Else: <$scope-test>"; // Prints "else-branch"
    $if-var; // error: undefined variable (was defined in a separate scope)
);
"Afterward: <$scope-test>"; // Global is untouched. Prints "global"

//= SCOPE ISOLATION: `Else if` HAS ITS OWN ISOLATED SCOPE
$level-scope: 1;
If $level-scope is 0, (
    $msg-scope: "Level 0";
), Else if $level-scope is 1, (
    $msg-scope: "Level 1"; // This shadows any outer $msg and is local to this block.
    "In Else If: <$msg-scope>"; // Prints "Level 1"
), Else, (
    $msg-scope: "Other Level";
);
$msg-scope; // error: undefined variable (each $msg was local to its own conditional block)

//= NESTED SHADOWING: INNER SCOPE SHADOWS OUTER SCOPE
$nest-scope: "level 1";
If True, (
    $nest-scope: "level 2"; // Shadows "level 1"
    If True, (
        $nest-scope: "level 3"; // Shadows "level 2"
        "Innermost scope: <$nest-scope>"; // Prints "level 3"
    );
    "Middle scope: <$nest-scope>"; // Prints "level 2", as inner scope has ended.
);
"Outermost scope: <$nest-scope>"; // Prints "level 1", as outer scopes have ended.

//= BASIC ASSIGNMENT: IF-TRUE PATH
// Assigns the result of the `If` block because the condition is true.
$age-33: 21;
$status-33: If $age-33 is at least 18, ("adult"), Else, ("minor");
$status-33; // prints "adult"

//= BASIC ASSIGNMENT: ELSE-FALSE PATH
// Assigns the result of the `Else` block because the condition is false.
$age-33 <: 16;
$status-333: If $age-33 is at least 18, ("adult"), Else, ("minor");
$status-333; // prints "minor"

//= REBINDING AN EXISTING VARIABLE
// The result of the conditional expression is used to rebind $status.
$status-33 <: If $age-33 is at least 13, ("teenager"), Else, ("child");
$status-33; // prints "teenager"

//= TYPE CONSISTENCY ON REBINDING
// The first assignment locks $result's type to Number. The second assignment
// attempts to rebind it with a Text from the Else block, which should fail.
$result-33: If True, (100), Else, (200);
$result-33; // prints 100
$result-33 <: If False, (300), Else, ("error-type"); // error: cannot bind Text to Number

//= NESTED INLINE CONDITIONALS IN ASSIGNMENT
// Tests that a nested conditional can resolve and its value be used by the outer conditional.
$is-member: False;
$cart-items: 2;
$shipping-cost: If $is-member, (
    0 // Free shipping for members
), Else, (
    If $cart-items is greater than 3, (
        5 // Reduced shipping for large orders
    ), Else, (
        10 // Standard shipping
    )
);
$shipping-cost; // prints 10

//= INLINE IF: BODY IS A SCOPE AND DOES NOT LEAK
$inline-test: "outer";
$result-scope: If True, ( $inline-test: "inner"; $inline-test ), Else, ( "never" );
"Result of inline If: <$result-scope>"; // Prints "inner"
"After inline If: <$inline-test>"; // Global is unaffected by the shadow. Prints "outer"

//= ANON REF: ASSIGNMENT TO A VARIABLE
// The simplest use case: storing an anonymous function reference in a variable.
$anon_ref_add_one: @(param $x: ; return($x + 1));
$anon_ref_add_one1: (param $x: ; return($x + 1));

// Prove it's a function by calling it.
$anon_ref_add_one(5); // prints 6
$anon_ref_add_one1(5); // prints 6

// Prove its type with a conditional check.
If $anon_ref_add_one is Function, (
    "Variable holds a function reference"; // Should print
);

If $anon_ref_add_one1 is Function, (
    "Variable holds a function reference"; // Should print
);

//= ANON REF: STORING IN A LIST
// A common use case for callbacks or strategies.
$anon_ref_ops: [
    @(param $n: ; $n * 2), // Doubler
    @(param $n: ; $n * $n), // Squarer
    "not-a-function"
];

$anon_ref_ops1: [
    (param $n: ; $n * 2), // Doubler
    (param $n: ; $n * $n), // Squarer
    "not-a-function"
];

// Invoke the first function from the list.
$anon_ref_ops.1(10); // prints 20
$anon_ref_ops1.1(10); // prints 20

// Invoke the second function from the list.
$anon_ref_ops.2(10); // prints 100
$anon_ref_ops1.2(10); // prints 100

//= ANON REF: PASSING DIRECTLY AS A FUNCTION ARGUMENT
// Defines a higher-order function that accepts a function and a value.
anon_ref_apply: (
    param $func: ();
    param $value: "";
    return( $func($value) );
);

// Pass an anonymous function reference directly as an argument.
anon_ref_apply( @(param $text: ; "Hello, <$text>!"), "Enzo" ); // prints "Hello, Enzo!"

//= ANON REF: IN A LIST PROPERTY (METHOD)
$anon_ref_calculator: [
    $base: 10,
    $op: @(param $x:; $x + $self.base)
];

$anon_ref_calculator1: [
    $base: 10,
    $op: (param $x:; $x + $self.base)
];

$anon_ref_calculator.op(5); // Uses $self to access list properties. Prints 15
$anon_ref_calculator1.op(5); // Uses $self to access list properties. Prints 15

//= ANON REF: NESTED ANONYMOUS REFERENCE
// An anonymous function that *returns* another anonymous function reference.
$anon_ref_creator: @(
    param $prefix: ;
    return( @(param $text:; "<$prefix> <$text>") );
);

$anon_ref_creator1: (
    param $prefix: ;
    return( @(param $text:; "<$prefix> <$text>") );
);

// Call the outer function to get the inner function.
$anon_ref_logger: $anon_ref_creator("[LOG]");
$anon_ref_logger1: $anon_ref_creator1("[LOG]");

// Call the inner function.
$anon_ref_logger("System Ready"); // prints "[LOG] System Ready"
$anon_ref_logger1("System Ready"); // prints "[LOG] System Ready"

//= ERROR CASE: FORGETTING THE `@` SIGIL
// Without `@`, the function atom is immediately evaluated (demand-driven).
// It returns a Function *object*, which is not a Number, causing a type error inside the function.
anon_ref_apply( (param $x:5; $x * 2), "text" ); // error: param expects Function type

//= ERROR CASE: SYNTAX ERROR INSIDE THE FUNCTION BODY
$anon_ref_bad_syntax: @(param $x: $x + ); // error: parse error in Function atom body

//= CLOSURE: BASIC FUNCTION FACTORY
// Tests the primary closure pattern: a function-making function.
clos_make_adder: (
    param $add_by: ;
    return( @(param $num: ; $num + $add_by) );
);

// Create two distinct closures with different captured environments.
$clos_add2: clos_make_adder(2);
$clos_add99: clos_make_adder(99);

$clos_add2(10);   // prints 12
$clos_add99(1);   // prints 100

// the below have not yet be vetted
//= CLOSURE: STATEFUL COUNTER (ENCAPSULATION)
// Proves that a closure can be used to maintain a private, mutable state.
clos_make_counter: (
    $count: 0; // This variable is private to the closure's environment.
    return( @(
        $count + 1 :> $count; // Mutate the captured variable
        return($count);
    ) );
);

$clos_counter_A: clos_make_counter();
$clos_counter_A(); // prints 1
$clos_counter_A(); // prints 2

$clos_counter_B: clos_make_counter(); // A completely separate counter
$clos_counter_B(); // prints 1

$clos_counter_A(); // prints 3 (A's state is independent of B's)

//= CLOSURE: INTERACTION WITH GLOBAL SCOPE SHADOWING
// Proves the closure uses the variable from its creation scope, not the global scope.
$clos_shadow: "global";

clos_creator: (
    $clos_shadow: "captured"; // This is the variable that should be remembered.
    return( @( return($clos_shadow) ) );
);

$clos_my_closure: clos_creator();
"global" :> $clos_shadow; // Change the global variable *after* the closure is created.

$clos_my_closure(); // prints "captured", proving it uses its remembered scope.

//= CLOSURE: STORED IN A DATA STRUCTURE
// Proves a closure maintains its scope even when stored in a list.
$clos_list: [
    clos_make_adder(10), // Store the closure in the list
    clos_make_adder(-1)
];

$clos_list.1(5);  // prints 15
$clos_list.2(5);  // prints 4

//= IMMEDIATE INVOCATION: BINDING VALUE VS. FUNCTION
// This is the core test. It proves that `!` changes the type of the bound variable.
$imm_func: (2 + 2);   // Stored as a Function object
$imm_value: !(2 + 2); // Immediately evaluated and stored as a Number

// Prove the type of $imm_func by using it as a function.
If $imm_func is Function, (
    "imm_func is a Function"; // Should print
);
$imm_func(); // Should print 4

// Prove the type of $imm_value by using it as a number.
If $imm_value is Number, (
    "imm_value is a Number"; // Should print
);
$imm_value + 1; // Should print 5

//= IMMEDIATE INVOCATION: REBINDING AND TYPE LOCKING
$imm_result: ; // Initially empty
$imm_result <: !(5 * 5); // Rebinds with a Number, locking the type
$imm_result; // prints 25

$imm_result <: !(10 - 4); // Rebinding with another Number is fine
$imm_result; // prints 6

$imm_result <: !("hello"); // error: cannot bind Text to Number

//= IMMEDIATE INVOCATION: IN A LIST LITERAL
// The contents are proven by how we use them later.
$imm_list: [
    10,
    !(10 + 10), // Evaluated to 20 (Number)
    (10 + 20)  // Stored as a Function
];
$imm_list.1;     // prints 10
$imm_list.2;     // prints 20
$imm_list.3();   // Invoke the stored function, prints 30

//= IMMEDIATE INVOCATION: AS A FUNCTION ARGUMENT
// The `!` forces evaluation *before* the value is passed to the function's parameter.
imm_square: (
    param $num: 0;
    return($num * $num);
);

imm_square( !(2 + 3) ); // The function receives the value 5, not the function atom. Prints 25

//= IMMEDIATE INVOCATION: WITH MULTI-STATEMENT BODY
// Proves that `!` works with complex function atoms and their scope does not leak.
$imm_complex_value: !(
    $imm_a: 100;
    $imm_b: 50;
    return($imm_a - $imm_b); // Using explicit return
);
$imm_complex_value; // prints 50
$imm_a; // error: undefined variable

//= IMMEDIATE INVOCATION: REDUNDANT BUT VALID USE
// In contexts where demand-driven evaluation already applies, `!` is unnecessary but should still work.
// 1. As a top-level statement
!(3 * 3); // prints 9, same as (3*3)

// 2. In string interpolation
"Value is: <!(4+4)>"; // prints "Value is: 8", same as "<(4+4)>"

//= ERROR CASE: `!` NOT FOLLOWED BY A FUNCTION ATOM
$imm_bad: !5; // error: The `!` sigil for immediate invocation must be followed by a function atom `(...)`.

//= ERROR CASE: SYNTAX ERROR INSIDE THE FUNCTION ATOM
$imm_bad2: !($x + ); // error: parse error in function atom body

//= RECURSION: CLASSIC FACTORIAL
// Tests the basic recursive pattern: a base case and a recursive step.
rec_factorial: (
    param $n: ;
    // 1. Base case to terminate recursion
    If $n is at most 1, (
        return(1);
    );
    // 2. Recursive step: call itself with a modified argument
    return( $n * rec_factorial($n - 1) );
);

rec_factorial(5); // prints 120 (5 * 4 * 3 * 2 * 1)
rec_factorial(1); // prints 1 (tests the base case directly)

//= RECURSION: MUTUAL RECURSION FOR EVEN/ODD
// Tests if two functions can call each other, proving they exist in the same scope.
rec_is_even: (
    param $n: ;
    If $n is 0, ( return(True) );
    return( rec_is_odd($n - 1) );
);
rec_is_odd: (
    param $n: ;
    If $n is 0, ( return(False) );
    return( rec_is_even($n - 1) );
);

rec_is_even(10); // prints True
rec_is_odd(7);   // prints True
rec_is_even(5);  // prints False

//= RECURSION: SCOPE INTEGRITY WITH SHADOWING
// Proves that each recursive call gets its own scope for parameters,
// correctly shadowing the global variable.
$rec_n: 100;
rec_countdown: (
    param $rec_n: 3; // This $n shadows the global $rec_n
    $rec_n; // prints the local parameter's value
    If $rec_n is greater than 0, (
		$rec_n - 1 :> $rec_n;
        rec_countdown($rec_n);
    );
);

rec_countdown(3); // prints 3, then 2, then 1, then 0
"Global n is still: <$rec_n>"; // prints "Global n is still: 100"

//= RECURSION: WITH A NAMED ANONYMOUS REFERENCE
// Tests that a function reference bound to a variable can call itself.
$rec_anon_factorial: @(
    param $n: ;
    If $n is 0, ( return(1) );
    // The function must use its own variable name to recurse
    return( $n * $rec_anon_factorial($n - 1) );
);

$rec_anon_factorial(4); // prints 24

//= RECURSION: STACK OVERFLOW PROTECTION
// Tests the interpreter's ability to handle infinite recursion gracefully.
rec_infinite: (
    rec_infinite(); // This function will call itself forever
);

rec_infinite(); // error: Maximum recursion depth exceeded

//= METHOD REFERENCING: BASICS
$pet: [
    $name: "Spot",
    speak: (
        return("Woof! My name is <$self.name>");
    ),
    age-increment: (
        $self.age + 1 :> $self.age;
    ),
    $age: 5
];

// Reference a method without invoking it
$ref-speak: @pet.speak;
$ref-speak;                // prints "Woof! My name is Spot"
$ref-speak();              // prints "Woof! My name is Spot"

//= METHOD REFERENCE PASSED AS ARGUMENT
call-method: (
    param $fn-ref:;
    return($fn-ref());
);

call-method(@pet.speak);   // prints "Woof! My name is Spot"

//= METHOD REFERENCE WITH STATE MUTATION
$ref-age: @pet.age-increment;
$ref-age();                 // should increment $pet.age → 6
$ref-age();                 // should increment $pet.age → 7
$pet.age;                   // should print 7

//= METHOD REFERENCE TO ANONYMOUS FUNCTION INSIDE LIST
$list-funcs: [
    $adder: (
        param $x:;
        return($x + 10);
    )
];

$ref-adder: @list-funcs.adder;
$ref-adder(5);              // prints 15

//= METHOD REFERENCE: NESTED LIST
$outer2: [
    $inner: [
        $say-hi: (
            return("hi from inner");
        )
    ]
];

$ref-hi: @outer2.inner.say-hi;
$ref-hi();                  // prints "hi from inner"

//= METHOD REFERENCE ERROR: NON-EXISTENT METHOD
$bad-ref: @pet.nonexistent;   // error: List property not found: $nonexistent

//= BLUEPRINT METHOD REFERENCING: BASICS
Animal1: <[
    name: Text,
    speak: (
        return("I am <$self.name>");
    )
]>;

$dog1: Animal1[$name: "Fido"];
$ref-speak-animal: @dog1.speak;
$ref-speak-animal();      // prints "I am Fido"

//= BLUEPRINT METHOD WITH STATE MUTATION ──────────────────────
Counter3: <[
    count: Number,
    increment: (
        $self.count + 1 :> $self.count;
        return($self.count);
    )
]>;

$c3: Counter3[$count: 0];
$ref-inc: @c3.increment;
$ref-inc();               // prints 1
$ref-inc();               // prints 2
$c3.count;                 // prints 2

//= METHOD REFERENCE PASSED INTO FUNCTION (BLUEPRINT) ─────────
invoke-method: (
    param $fn-ref:;
    return($fn-ref());
);

invoke-method(@c3.increment);  // prints 3 (increments again)

//= VARIANT METHOD REFERENCING ────────────────────────────────
GoblinV: <[
    hp: Number,
    cackle: (
        return("heeheehee");
    )
]>;
OrcV: <[
    hp: Number,
    shout: (
        return("Manmeat for dinner!");
    )
]>;

MonsterV variants: GoblinV, or OrcV;

$g3: MonsterV.GoblinV[$hp: 25];
$o3: MonsterV.OrcV[$hp: 40];

$ref-cackle: @g3.cackle;
$ref-cackle();            // prints "heeheehee"

$ref-shout: @o3.shout;
$ref-shout();             // prints "Manmeat for dinner!"

//= VARIANT METHOD PASSED INTO FUNCTION ───────────────────────
do-twice: (
    param $fn:;
    $fn();
    return($fn());
);

do-twice(@g3.cackle);      // prints "heeheehee" twice

//= ERROR: METHOD REFERENCE TO NON-EXISTENT VARIANT METHOD ────
$bad-ref-v: @g3.nonexistent;  // error: List property not found: $nonexistent
