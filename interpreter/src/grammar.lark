# ──────────────────────────────────────────────────────────────────────────────
# grammar.lark
# ──────────────────────────────────────────────────────────────────────────────

# Top‐level: one or more statements, separated (and optionally
# terminated) by semicolons (“;”).  Newlines are not significant here—
# only “;” really ends a statement.
start: _nl* stmt (";" _nl* stmt)* ";"? _nl*

# A single statement is either an assignment form or a bare expression.
?stmt: assign_stmt
     | return_stmt
     | expr              -> expr_stmt

return_stmt: RETURN "(" expr ")" ";"


# ── assignment forms ─────────────────────────────────────────────────────────
?assign_stmt: FUNCNAME ":" expr  -> bind_func
            | NAME ":"  expr      -> bind
            | NAME ":"            -> bind_empty
            | NAME "<:" expr       -> rebind
            | expr "<:" expr       -> prop_rebind
            | expr ":>" NAME       -> rebind_lr

# ── full expression precedence ────────────────────────────────────────────────
?expr: sum

?sum: product
    | sum "+" product             -> add
    | sum "-" product             -> sub

?product: unary
        | product "*" unary       -> mul
        | product "/" unary       -> div

# Handle unary minus as right-associative, so -5, -x, or --5 all work
?unary: "-" unary                -> neg
      | postfix

# ── postfix handles “.INT” (list‐index), “.$foo” (var‐index), or “.foo” (prop‐access)
?postfix: atom ( DOTINT | DOTVAR | DOTPROP )*    -> index_chain

# All values, calls, and blocks are atoms
?atom: list_literal
     | table_literal
     | block_expr              -> block_expr
     | call                    -> call
     | func_ref                -> func_ref
     | SIGNED_NUMBER           -> number
     | STRING                  -> string
     | var

var: NAME

# --- function object reference ---
func_ref: ATNAME

##############################################################################
# BLOCK EXPRESSION:
#   - Every parenthesis is a new scope/block.
#   - Params and statements can be separated by "," or ";" (or mixed).
#   - Both:
#         ($x: 1, $y: 2; $x + $y);
#         ($x: 1; $y: 2; $x + $y);
#     ...are valid and treated identically.
#   - Multi-line forms are also supported:
#         (
#            $x: 1,
#            $y: 2;
#            return($x + $y);
#         );
##############################################################################

# All parens become block_expr, with any order/combination of bindings, params, statements (including return), and expressions.
block_expr: LPAR block_body RPAR

block_body: _nl* (block_item block_sep)* block_item block_sep? _nl*

block_item: param_binding
          | block_binding
          | return_stmt
          | expr
block_binding: (NAME | FUNCNAME) ":" expr
param_binding: PARAM NAME ":" expr
block_sep: _nl* ("," | ";") _nl*



# ── function call ────────────────────────────────────────────────
call: (NAME | FUNCNAME) "(" [call_args] ")"
call_args: expr ("," expr)* [","]

# ── list literal ─────────────────────────────────────────────────────────────
list_literal: "[" _nl* "]"                          -> list
            | "[" _nl* expr_list _nl* "]"           -> list
expr_list: expr (list_sep expr)* [list_sep]
list_sep: _nl* "," _nl* | _nl+

# ── table literal ────────────────────────────────────────────────────────────
table_literal: "{" _nl* "}"                          -> table
             | "{" _nl* kvpair_list _nl* "}"         -> table
kvpair_list: kvpair (kvpair_sep kvpair)* [kvpair_sep]
kvpair_sep: _nl* "," _nl* | _nl+
kvpair: NAME ":" expr

# ── tokens ───────────────────────────────────────────────────────────────────

# ── Helper for repeated (possibly empty) newlines
_nl: NEWLINE

PARAM.1: "param"
RETURN.1: "return"
NAME.3:    /\$[a-zA-Z0-9_-]+/
FUNCNAME.10: /[a-zA-Z_][a-zA-Z0-9_-]*/

DOTINT.5:   /\.[1-9][0-9]*/            // “.1”, “.42”  1‐based numeric indexing
DOTVAR.6:   /\.[$][a-zA-Z0-9_-]+/      // “.$foo”
DOTPROP.7:  /\.[a-zA-Z][a-zA-Z0-9_-]*/ // “.foo”  (property‐access)

ATNAME: "@" FUNCNAME

NEWLINE: /(\r?\n)+/
LPAR: "("
RPAR: ")"


SIGNED_NUMBER.2: /[0-9]+/
%import common.ESCAPED_STRING   -> STRING
%import common.WS_INLINE

# ── ignore spaces/tabs, single‐line “//” comments, and newlines ───────────────
%ignore WS_INLINE
