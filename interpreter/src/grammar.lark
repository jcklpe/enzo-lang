# ──────────────────────────────────────────────────────────────────────────────
# grammar.lark
# ──────────────────────────────────────────────────────────────────────────────

##############################################################################
# Only atoms may be top-level statements, NOT arbitrary expressions.
# Atoms = number, text atom, list, table, block_expr (function atom)
##############################################################################
start: _nl* stmt (";" _nl* stmt)* ";"? _nl*

?stmt: assign_stmt
     | return_stmt
     | postfix              -> expr_stmt

return_stmt: RETURN "(" expr ")" ";"

# ── assignment forms ─────────────────────────────────────────────────────────
?assign_stmt: FUNCNAME ":" expr  -> bind_func
            | NAME ":"  expr      -> bind
            | NAME ":"            -> bind_empty
            | NAME "<:" expr       -> rebind
            | expr "<:" expr       -> prop_rebind
            | expr ":>" NAME       -> rebind_lr

# ── full expression precedence ────────────────────────────────────────────────
?expr: sum

?sum: product
    | sum "+" product             -> add
    | sum "-" product             -> sub

?product: postfix
        | product "*" postfix     -> mul
        | product "/" postfix     -> div

# ── postfix handles “.INT” (list‐index), “.$foo” (var‐index), or “.foo” (prop‐access)
?postfix: primary ( DOTINT | DOTVAR | DOTPROP )*    -> index_chain

?primary: list_literal
        | table_literal
        | block_expr              -> block_expr
        | call                    -> call
        | SIGNED_NUMBER           -> number
        | TEXT_ATOM               -> text_atom
        | NAME                    -> var

##############################################################################
# BLOCK EXPRESSION:
#   - Every parenthesis is a new scope/block.
#   - Params and statements can be separated by "," or ";" (or mixed).
#   - Both:
#         ($x: 1, $y: 2; $x + $y);
#         ($x: 1; $y: 2; $x + $y);
#     ...are valid and treated identically.
#   - Multi-line forms are also supported:
#         (
#            $x: 1,
#            $y: 2;
#            return($x + $y);
#         );
##############################################################################

# All parens become block_expr, with any order/combination of bindings, params, statements (including return), and expressions.
block_expr: LPAR block_body RPAR

block_body: _nl* (block_item block_sep)* block_item block_sep? _nl*

block_item: param_binding
          | block_binding
          | return_stmt
          | expr
block_binding: (NAME | FUNCNAME) ":" expr
param_binding: PARAM NAME ":" expr
block_sep: _nl* ("," | ";") _nl*


# ── function call ────────────────────────────────────────────────
call: (NAME | FUNCNAME) "(" [call_args] ")"
call_args: expr ("," expr)* [","]

# ── list literal ─────────────────────────────────────────────────────────────
list_literal: "[" _nl* "]"                          -> list
            | "[" _nl* expr_list _nl* "]"           -> list
expr_list: expr (list_sep expr)* [list_sep]
list_sep: _nl* "," _nl* | _nl+

# ── table literal ────────────────────────────────────────────────────────────
table_literal: "{" _nl* "}"                          -> table
             | "{" _nl* table_item_list _nl* "}"         -> table
table_item_list: table_item (kvpair_sep table_item)* [kvpair_sep]
kvpair_sep: _nl* "," _nl* | _nl+
table_item: NAME ":" expr

# ── Helper for repeated (possibly empty) newlines
_nl: NEWLINE

# ── tokens ───────────────────────────────────────────────────────────────────
NAME:    /\$[a-zA-Z0-9_-]+/
FUNCNAME: /[a-zA-Z0-9_-]+/

DOTINT.5:   /\.[1-9][0-9]*/            // “.1”, “.42”  1‐based numeric indexing
DOTVAR.6:   /\.[\$][a-zA-Z0-9_-]+/      // “.$foo”
DOTPROP.7:  /\.[a-zA-Z][a-zA-Z0-9_-]*/ // “.foo”  (property‐access)

NEWLINE: /(\r?\n)+/

LPAR: "("
RPAR: ")"
PARAM: "param"
RETURN: "return"

%import common.SIGNED_NUMBER
%import common.ESCAPED_STRING   -> TEXT_ATOM
%import common.WS_INLINE

# ── ignore spaces/tabs, single‐line “//” comments, and newlines ───────────────
%ignore WS_INLINE
# %ignore /\/\/[^\n]*/
#
# Note: In Enzo, a text atom is any sequence of characters in double quotes, e.g. "hello". The TEXT_ATOM token matches these.
